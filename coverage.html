
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>migrate: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">enterprise-blog/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file1">enterprise-blog/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">enterprise-blog/internal/config/config.go (0.0%)</option>
				
				<option value="file3">enterprise-blog/internal/database/database.go (0.0%)</option>
				
				<option value="file4">enterprise-blog/internal/database/redis.go (0.0%)</option>
				
				<option value="file5">enterprise-blog/internal/handlers/admin_handler.go (0.0%)</option>
				
				<option value="file6">enterprise-blog/internal/handlers/article_handler.go (0.0%)</option>
				
				<option value="file7">enterprise-blog/internal/handlers/category_handler.go (0.0%)</option>
				
				<option value="file8">enterprise-blog/internal/handlers/comment_handler.go (0.0%)</option>
				
				<option value="file9">enterprise-blog/internal/handlers/image_handler.go (0.0%)</option>
				
				<option value="file10">enterprise-blog/internal/handlers/tag_handler.go (0.0%)</option>
				
				<option value="file11">enterprise-blog/internal/handlers/user_handler.go (0.0%)</option>
				
				<option value="file12">enterprise-blog/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file13">enterprise-blog/internal/middleware/cors.go (0.0%)</option>
				
				<option value="file14">enterprise-blog/internal/middleware/logger.go (0.0%)</option>
				
				<option value="file15">enterprise-blog/internal/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file16">enterprise-blog/internal/models/article.go (0.0%)</option>
				
				<option value="file17">enterprise-blog/internal/models/response.go (0.0%)</option>
				
				<option value="file18">enterprise-blog/internal/models/user.go (0.0%)</option>
				
				<option value="file19">enterprise-blog/internal/repository/article_repository.go (0.0%)</option>
				
				<option value="file20">enterprise-blog/internal/repository/category_repository.go (0.0%)</option>
				
				<option value="file21">enterprise-blog/internal/repository/comment_repository.go (0.0%)</option>
				
				<option value="file22">enterprise-blog/internal/repository/image_repository.go (0.0%)</option>
				
				<option value="file23">enterprise-blog/internal/repository/sms_repository.go (0.0%)</option>
				
				<option value="file24">enterprise-blog/internal/repository/tag_repository.go (0.0%)</option>
				
				<option value="file25">enterprise-blog/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file26">enterprise-blog/internal/search/elasticsearch.go (0.0%)</option>
				
				<option value="file27">enterprise-blog/internal/services/article_service.go (0.0%)</option>
				
				<option value="file28">enterprise-blog/internal/services/category_service.go (0.0%)</option>
				
				<option value="file29">enterprise-blog/internal/services/comment_service.go (0.0%)</option>
				
				<option value="file30">enterprise-blog/internal/services/image_service.go (0.0%)</option>
				
				<option value="file31">enterprise-blog/internal/services/sms_service.go (0.0%)</option>
				
				<option value="file32">enterprise-blog/internal/services/tag_service.go (0.0%)</option>
				
				<option value="file33">enterprise-blog/internal/services/user_service.go (0.0%)</option>
				
				<option value="file34">enterprise-blog/pkg/jwt/jwt.go (0.0%)</option>
				
				<option value="file35">enterprise-blog/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file36">enterprise-blog/pkg/metrics/metrics.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "enterprise-blog/internal/config"
        "enterprise-blog/internal/database"
        "enterprise-blog/pkg/logger"
)

type Migration struct {
        Version int
        Name    string
        Up      string
        Down    string
}

func main() <span class="cov0" title="0">{
        // 加载配置
        if err := config.Load(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load config: %v", err))</span>
        }

        // 初始化日志
        <span class="cov0" title="0">if err := logger.Init("info", ""); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to init logger: %v", err))</span>
        }

        // 初始化数据库（使用 GORM）
        <span class="cov0" title="0">if err := database.Init(); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Fatal().Err(err).Msg("Failed to connect to database")
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // 创建迁移表
        if err := createMigrationsTable(); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Fatal().Err(err).Msg("Failed to create migrations table")
        }</span>

        // 加载迁移文件
        <span class="cov0" title="0">migrations, err := loadMigrations()
        if err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Fatal().Err(err).Msg("Failed to load migrations")
        }</span>

        // 获取已执行的迁移
        <span class="cov0" title="0">executed, err := getExecutedMigrations()
        if err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Fatal().Err(err).Msg("Failed to get executed migrations")
        }</span>

        // 执行未执行的迁移
        <span class="cov0" title="0">for _, migration := range migrations </span><span class="cov0" title="0">{
                if executed[migration.Version] </span><span class="cov0" title="0">{
                        l := logger.GetLogger()
                        l.Info().Int("version", migration.Version).Msg("Migration already executed, skipping")
                        continue</span>
                }

                <span class="cov0" title="0">l := logger.GetLogger()
                l.Info().Int("version", migration.Version).Str("name", migration.Name).Msg("Running migration")

                tx := database.DB.Begin()
                if tx.Error != nil </span><span class="cov0" title="0">{
                        l := logger.GetLogger()
                        l.Fatal().Err(tx.Error).Msg("Failed to begin transaction")
                }</span>

                // 执行 up 迁移
                <span class="cov0" title="0">if err := tx.Exec(migration.Up).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        l := logger.GetLogger()
                        l.Fatal().Err(err).Int("version", migration.Version).Msg("Failed to execute migration")
                }</span>

                // 记录迁移
                <span class="cov0" title="0">if err := tx.Exec("INSERT INTO schema_migrations (version, name) VALUES ($1, $2)", migration.Version, migration.Name).Error; err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        l := logger.GetLogger()
                        l.Fatal().Err(err).Msg("Failed to record migration")
                }</span>

                <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                        l := logger.GetLogger()
                        l.Fatal().Err(err).Msg("Failed to commit transaction")
                }</span>

                <span class="cov0" title="0">l2 := logger.GetLogger()
                l2.Info().Int("version", migration.Version).Msg("Migration completed")</span>
        }

        <span class="cov0" title="0">l := logger.GetLogger()
        l.Info().Msg("All migrations completed")</span>
}

func createMigrationsTable() error <span class="cov0" title="0">{
        query := `
                CREATE TABLE IF NOT EXISTS schema_migrations (
                        version INTEGER PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        executed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
        `
        return database.DB.Exec(query).Error
}</span>

func loadMigrations() ([]Migration, error) <span class="cov0" title="0">{
        // 直接从项目根目录下的 migrations 目录读取 SQL 文件
        migrationsDir := filepath.Join("migrations")

        entries, err := os.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">migrationsMap := make(map[int]*Migration)

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".sql") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.Split(entry.Name(), "_")
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var version int
                var direction string
                var name string

                if _, err := fmt.Sscanf(parts[0], "%d", &amp;version); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">filename := entry.Name()
                if strings.HasSuffix(filename, ".up.sql") </span><span class="cov0" title="0">{
                        direction = "up"
                        name = strings.TrimSuffix(strings.TrimPrefix(filename, fmt.Sprintf("%03d_", version)), ".up.sql")
                }</span> else<span class="cov0" title="0"> if strings.HasSuffix(filename, ".down.sql") </span><span class="cov0" title="0">{
                        direction = "down"
                        name = strings.TrimSuffix(strings.TrimPrefix(filename, fmt.Sprintf("%03d_", version)), ".down.sql")
                }</span> else<span class="cov0" title="0"> {
                        continue</span>
                }

                <span class="cov0" title="0">content, err := os.ReadFile(filepath.Join(migrationsDir, filename))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if migrationsMap[version] == nil </span><span class="cov0" title="0">{
                        migrationsMap[version] = &amp;Migration{
                                Version: version,
                                Name:    name,
                        }
                }</span>

                <span class="cov0" title="0">if direction == "up" </span><span class="cov0" title="0">{
                        migrationsMap[version].Up = string(content)
                }</span> else<span class="cov0" title="0"> {
                        migrationsMap[version].Down = string(content)
                }</span>
        }

        <span class="cov0" title="0">var migrations []Migration
        for _, m := range migrationsMap </span><span class="cov0" title="0">{
                migrations = append(migrations, *m)
        }</span>

        <span class="cov0" title="0">sort.Slice(migrations, func(i, j int) bool </span><span class="cov0" title="0">{
                return migrations[i].Version &lt; migrations[j].Version
        }</span>)

        <span class="cov0" title="0">return migrations, nil</span>
}

func getExecutedMigrations() (map[int]bool, error) <span class="cov0" title="0">{
        var versions []int
        if err := database.DB.Raw("SELECT version FROM schema_migrations").Scan(&amp;versions).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">executed := make(map[int]bool)
        for _, v := range versions </span><span class="cov0" title="0">{
                executed[v] = true
        }</span>
        <span class="cov0" title="0">return executed, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "enterprise-blog/internal/config"
        "enterprise-blog/internal/database"
        "enterprise-blog/internal/handlers"
        "enterprise-blog/internal/middleware"
        "enterprise-blog/internal/repository"
        "enterprise-blog/internal/search"
        "enterprise-blog/internal/services"
        "enterprise-blog/pkg/jwt"
        "enterprise-blog/pkg/logger"
        "enterprise-blog/pkg/metrics"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func main() <span class="cov0" title="0">{
        // 加载配置
        if err := config.Load(); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to load config: %v", err))</span>
        }

        // 初始化日志
        <span class="cov0" title="0">if err := logger.Init(config.AppConfig.Log.Level, config.AppConfig.Log.File); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to init logger: %v", err))</span>
        }

        // 初始化数据库
        <span class="cov0" title="0">if err := database.Init(); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Fatal().Err(err).Msg("Failed to connect to database")
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // 初始化Redis
        if err := database.InitRedis(); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Warn().Err(err).Msg("Failed to connect to redis, continuing without cache")
        }</span> else<span class="cov0" title="0"> {
                defer database.CloseRedis()
        }</span>

        // 初始化 Elasticsearch（可选，失败仅记录日志）
        <span class="cov0" title="0">search.InitElasticsearch()

        // 初始化JWT管理器
        jwtMgr := jwt.NewJWTManager(config.AppConfig.JWT.Secret, config.AppConfig.JWT.ExpireDuration())

        // 初始化Repository
        userRepo := repository.NewUserRepository()
        articleRepo := repository.NewArticleRepository()
        categoryRepo := repository.NewCategoryRepository()
        tagRepo := repository.NewTagRepository()
        commentRepo := repository.NewCommentRepository()
        smsRepo := repository.NewSMSRepository()
        imageRepo := repository.NewImageRepository()

        // 初始化Service
        userService := services.NewUserService(userRepo, jwtMgr)
        smsService := services.NewSMSService(smsRepo, userRepo)
        articleService := services.NewArticleService(articleRepo, categoryRepo, tagRepo)
        categoryService := services.NewCategoryService(categoryRepo)
        tagService := services.NewTagService(tagRepo)
        commentService := services.NewCommentService(commentRepo, articleRepo)
        // 图片上传目录从配置文件读取
        imageService := services.NewImageService(imageRepo, config.AppConfig.Upload.Dir)

        // 初始化Handler
        userHandler := handlers.NewUserHandler(userService, smsService, jwtMgr)
        articleHandler := handlers.NewArticleHandler(articleService)
        categoryHandler := handlers.NewCategoryHandler(categoryService)
        tagHandler := handlers.NewTagHandler(tagService)
        commentHandler := handlers.NewCommentHandler(commentService)
        imageHandler := handlers.NewImageHandler(imageService)
        adminHandler := handlers.NewAdminHandler()

        // 设置Gin模式
        gin.SetMode(config.AppConfig.Server.Mode)

        // 创建路由
        router := gin.New()

        // 中间件
        router.Use(middleware.LoggerMiddleware())
        router.Use(metrics.MetricsMiddleware()) // Prometheus metrics中间件
        router.Use(middleware.CORSMiddleware())
        router.Use(gin.Recovery())

        // 健康检查
        router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "ok"})
        }</span>)

        // Prometheus metrics endpoint
        <span class="cov0" title="0">router.GET("/metrics", gin.WrapH(promhttp.Handler()))

        // 静态文件服务：上传的图片（需要在API路由组之前，避免路径冲突）
        router.Static("/uploads/images", config.AppConfig.Upload.Dir)

        // API路由组
        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // 公开路由
                public := api.Group("")
                </span><span class="cov0" title="0">{
                        // 用户认证
                        public.POST("/auth/register", userHandler.Register)
                        public.POST("/auth/login", userHandler.Login)
                        public.POST("/auth/send-sms-code", userHandler.SendSMSCode)
                        public.POST("/auth/login-phone", userHandler.LoginWithPhone)

                        // 文章（公开访问）
                        public.GET("/articles", articleHandler.List)
                        public.GET("/articles/:id", articleHandler.GetByID)
                        public.GET("/articles/slug/:slug", articleHandler.GetBySlug)
                        public.POST("/articles/:id/like", articleHandler.Like)

                        // 分类和标签
                        public.GET("/categories", categoryHandler.List)
                        public.GET("/tags", tagHandler.List)

                        // 评论（使用文章 ID 路径参数 id，与 /articles/:id 保持一致）
                        public.GET("/articles/:id/comments", commentHandler.GetByArticleID)
                        public.POST("/articles/:id/comments", commentHandler.Create)

                        // 图片（公开访问）
                        public.GET("/images", imageHandler.List)
                        public.GET("/images/:id", imageHandler.GetByID)
                }</span>

                // 需要认证的路由
                <span class="cov0" title="0">authenticated := api.Group("")
                authenticated.Use(middleware.AuthMiddleware(jwtMgr))
                authenticated.Use(middleware.RateLimitMiddleware(100, time.Minute))
                </span><span class="cov0" title="0">{
                        // 用户
                        authenticated.GET("/users/profile", userHandler.GetProfile)
                        authenticated.PUT("/users/profile", userHandler.UpdateProfile)
                        authenticated.PUT("/users/password", userHandler.ChangePassword)

                        // 文章（需要认证）
                        authenticated.POST("/articles", articleHandler.Create)
                        authenticated.PUT("/articles/:id", articleHandler.Update)
                        authenticated.DELETE("/articles/:id", articleHandler.Delete)

                        // 图片（需要认证）
                        authenticated.POST("/images/upload", imageHandler.Upload)
                        authenticated.PUT("/images/:id", imageHandler.Update)
                        authenticated.DELETE("/images/:id", imageHandler.Delete)
                }</span>

                // 管理员路由
                <span class="cov0" title="0">admin := api.Group("/admin")
                admin.Use(middleware.AuthMiddleware(jwtMgr))
                admin.Use(middleware.RoleMiddleware("admin"))
                </span><span class="cov0" title="0">{
                        // 仪表盘 &amp; 系统配置
                        admin.GET("/dashboard", adminHandler.Dashboard)
                        admin.GET("/system/config", adminHandler.SystemConfig)

                        admin.GET("/users", userHandler.ListUsers)
                        admin.GET("/users/:id", userHandler.GetUser)
                        admin.PUT("/users/:id", userHandler.AdminUpdateUser)
                        // 管理后台文章管理
                        admin.GET("/articles", articleHandler.AdminList)
                        admin.GET("/articles/:id", articleHandler.AdminGetByID)
                        admin.PUT("/articles/:id/status", articleHandler.AdminUpdateStatus)
                        admin.DELETE("/articles/:id", articleHandler.AdminDelete)

                        // 管理后台分类与标签管理
                        admin.GET("/categories", categoryHandler.List)
                        admin.POST("/categories", categoryHandler.Create)
                        admin.GET("/categories/:id", categoryHandler.GetByID)
                        admin.PUT("/categories/:id", categoryHandler.Update)
                        admin.DELETE("/categories/:id", categoryHandler.Delete)

                        admin.GET("/tags", tagHandler.List)
                        admin.POST("/tags", tagHandler.Create)
                        admin.GET("/tags/:id", tagHandler.GetByID)
                        admin.PUT("/tags/:id", tagHandler.Update)
                        admin.DELETE("/tags/:id", tagHandler.Delete)
                }</span>
        }

        // 启动服务器
        <span class="cov0" title="0">addr := fmt.Sprintf("%s:%s", config.AppConfig.Server.Host, config.AppConfig.Server.Port)
        srv := &amp;http.Server{
                Addr:    addr,
                Handler: router,
        }

        // 启动 Redis 计数回刷 goroutine（view_count / like_count）
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()
                for range ticker.C </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                        _ = services.FlushArticleCountersFromRedis(ctx)
                        cancel()
                }</span>
        }()

        // 优雅关闭
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        l := logger.GetLogger()
                        l.Fatal().Err(err).Msg("Failed to start server")
                }</span>
        }()

        <span class="cov0" title="0">l := logger.GetLogger()
        l.Info().Str("address", addr).Msg("Server started")

        // 等待中断信号
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        l2 := logger.GetLogger()
        l2.Info().Msg("Shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                l3 := logger.GetLogger()
                l3.Fatal().Err(err).Msg("Server forced to shutdown")
        }</span>

        <span class="cov0" title="0">l4 := logger.GetLogger()
        l4.Info().Msg("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

type Config struct {
        Server        ServerConfig
        Database      DatabaseConfig
        Redis         RedisConfig
        Elasticsearch ElasticsearchConfig
        JWT           JWTConfig
        Log           LogConfig
        Upload        UploadConfig
}

type ServerConfig struct {
        Host string
        Port string
        Mode string
}

type DatabaseConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        Name     string
        SSLMode  string
        // 连接池配置
        MaxOpenConns           int
        MaxIdleConns           int
        ConnMaxLifetimeMinutes int
}

type RedisConfig struct {
        Host     string
        Port     string
        Password string
        DB       int
}

type ElasticsearchConfig struct {
        URL     string
        Enabled bool
}

type JWTConfig struct {
        Secret      string
        ExpireHours int
}

type LogConfig struct {
        Level string
        File  string
}

type UploadConfig struct {
        Dir         string
        MaxSize     int64
        AllowedExts []string
}

var AppConfig *Config

func Load() error <span class="cov0" title="0">{
        // 加载 .env 文件（如果存在）
        _ = godotenv.Load()

        AppConfig = &amp;Config{
                Server: ServerConfig{
                        Host: getEnv("SERVER_HOST", "0.0.0.0"),
                        Port: getEnv("SERVER_PORT", "8080"),
                        Mode: getEnv("SERVER_MODE", "debug"),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnv("DB_PORT", "5432"),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "postgres"),
                        Name:     getEnv("DB_NAME", "enterprise_blog"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                        // 默认值适用于中小规模部署，可通过环境变量覆盖
                        MaxOpenConns:           getEnvAsInt("DB_MAX_OPEN_CONNS", 50),
                        MaxIdleConns:           getEnvAsInt("DB_MAX_IDLE_CONNS", 10),
                        ConnMaxLifetimeMinutes: getEnvAsInt("DB_CONN_MAX_LIFETIME_MINUTES", 60),
                },
                Redis: RedisConfig{
                        Host:     getEnv("REDIS_HOST", "localhost"),
                        Port:     getEnv("REDIS_PORT", "6379"),
                        Password: getEnv("REDIS_PASSWORD", ""),
                        DB:       getEnvAsInt("REDIS_DB", 0),
                },
                Elasticsearch: ElasticsearchConfig{
                        URL:     getEnv("ELASTICSEARCH_URL", ""),
                        Enabled: getEnv("ELASTICSEARCH_ENABLED", "true") == "true",
                },
                JWT: JWTConfig{
                        Secret:      getEnv("JWT_SECRET", "your-secret-key-change-in-production"),
                        ExpireHours: getEnvAsInt("JWT_EXPIRE_HOURS", 24),
                },
                Log: LogConfig{
                        Level: getEnv("LOG_LEVEL", "debug"),
                        File:  getEnv("LOG_FILE", "logs/app.log"),
                },
                Upload: UploadConfig{
                        Dir:         getEnv("UPLOAD_DIR", "./uploads/images"),
                        MaxSize:     int64(getEnvAsInt("MAX_UPLOAD_SIZE", 10485760)), // 默认10MB
                        AllowedExts: []string{".jpg", ".jpeg", ".png", ".gif", ".webp"},
                },
        }

        return nil
}</span>

func (d DatabaseConfig) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                d.Host, d.Port, d.User, d.Password, d.Name, d.SSLMode)
}</span>

func (r RedisConfig) Addr() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", r.Host, r.Port)
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        valueStr := getEnv(key, "")
        if value, err := strconv.Atoi(valueStr); err == nil </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func (j JWTConfig) ExpireDuration() time.Duration <span class="cov0" title="0">{
        return time.Duration(j.ExpireHours) * time.Hour
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "fmt"
        "time"

        "enterprise-blog/internal/config"
        "enterprise-blog/pkg/logger"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

// DB 是全局的 GORM 数据库连接
var DB *gorm.DB

func Init() error <span class="cov0" title="0">{
        dsn := config.AppConfig.Database.DSN()

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // 配置连接池（通过底层 *sql.DB）
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sql.DB from gorm: %w", err)
        }</span>

        // 使用配置中的连接池参数
        <span class="cov0" title="0">maxOpen := config.AppConfig.Database.MaxOpenConns
        maxIdle := config.AppConfig.Database.MaxIdleConns
        lifeMinutes := config.AppConfig.Database.ConnMaxLifetimeMinutes

        if maxOpen &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxOpenConns(maxOpen)
        }</span>
        <span class="cov0" title="0">if maxIdle &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetMaxIdleConns(maxIdle)
        }</span>
        <span class="cov0" title="0">if lifeMinutes &gt; 0 </span><span class="cov0" title="0">{
                sqlDB.SetConnMaxLifetime(time.Duration(lifeMinutes) * time.Minute)
        }</span>

        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">DB = db
        l := logger.GetLogger()
        l.Info().Msg("Database connected successfully")

        return nil</span>
}

func Close() error <span class="cov0" title="0">{
        if DB == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqlDB.Close()</span>
}

</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "context"
        "fmt"

        "enterprise-blog/internal/config"
        "enterprise-blog/pkg/logger"

        "github.com/redis/go-redis/v9"
)

var RedisClient *redis.Client

func InitRedis() error <span class="cov0" title="0">{
        RedisClient = redis.NewClient(&amp;redis.Options{
                Addr:     config.AppConfig.Redis.Addr(),
                Password: config.AppConfig.Redis.Password,
                DB:       config.AppConfig.Redis.DB,
        })

        ctx := context.Background()
        if err := RedisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to redis: %w", err)
        }</span>

        <span class="cov0" title="0">l := logger.GetLogger()
        l.Info().Msg("Redis connected successfully")
        return nil</span>
}

func CloseRedis() error <span class="cov0" title="0">{
        if RedisClient != nil </span><span class="cov0" title="0">{
                return RedisClient.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/config"
        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/gin-gonic/gin"
)

// AdminHandler 提供仪表盘和系统配置等后台管理接口
type AdminHandler struct{}

func NewAdminHandler() *AdminHandler <span class="cov0" title="0">{
        return &amp;AdminHandler{}
}</span>

// AdminDashboardData 仪表盘统计数据
type AdminDashboardData struct {
        TotalUsers          int64 `json:"total_users"`
        TotalArticles       int64 `json:"total_articles"`
        PublishedArticles   int64 `json:"published_articles"`
        DraftArticles       int64 `json:"draft_articles"`
        ArchivedArticles    int64 `json:"archived_articles"`
        TotalComments       int64 `json:"total_comments"`
        TotalArticleViews   int64 `json:"total_article_views"`
        TotalArticleLikes   int64 `json:"total_article_likes"`
        TodayPublishedCount int64 `json:"today_published_count"`
}

// Dashboard 返回后台仪表盘核心统计
func (h *AdminHandler) Dashboard(c *gin.Context) <span class="cov0" title="0">{
        var data AdminDashboardData

        // 用户总数
        _ = database.DB.Raw("SELECT COUNT(*) FROM users WHERE deleted_at IS NULL").Scan(&amp;data.TotalUsers).Error

        // 文章相关统计
        _ = database.DB.Raw("SELECT COUNT(*) FROM articles WHERE deleted_at IS NULL").Scan(&amp;data.TotalArticles).Error
        _ = database.DB.Raw("SELECT COUNT(*) FROM articles WHERE status = 'published' AND deleted_at IS NULL").Scan(&amp;data.PublishedArticles).Error
        _ = database.DB.Raw("SELECT COUNT(*) FROM articles WHERE status = 'draft' AND deleted_at IS NULL").Scan(&amp;data.DraftArticles).Error
        _ = database.DB.Raw("SELECT COUNT(*) FROM articles WHERE status = 'archived' AND deleted_at IS NULL").Scan(&amp;data.ArchivedArticles).Error
        _ = database.DB.Raw("SELECT COALESCE(SUM(view_count), 0) FROM articles WHERE deleted_at IS NULL").Scan(&amp;data.TotalArticleViews).Error
        _ = database.DB.Raw("SELECT COALESCE(SUM(like_count), 0) FROM articles WHERE deleted_at IS NULL").Scan(&amp;data.TotalArticleLikes).Error
        _ = database.DB.Raw("SELECT COUNT(*) FROM articles WHERE status = 'published' AND deleted_at IS NULL AND DATE(published_at) = CURRENT_DATE").Scan(&amp;data.TodayPublishedCount).Error

        // 评论总数
        _ = database.DB.Raw("SELECT COUNT(*) FROM comments WHERE deleted_at IS NULL").Scan(&amp;data.TotalComments).Error

        c.JSON(http.StatusOK, models.Success(data))
}</span>

// SystemConfigInfo 对外暴露的系统配置（脱敏）
type SystemConfigInfo struct {
        Server struct {
                Host string `json:"host"`
                Port string `json:"port"`
                Mode string `json:"mode"`
        } `json:"server"`
        Database struct {
                Host               string `json:"host"`
                Port               string `json:"port"`
                User               string `json:"user"`
                Name               string `json:"name"`
                MaxOpenConns       int    `json:"max_open_conns"`
                MaxIdleConns       int    `json:"max_idle_conns"`
                ConnMaxLifetimeMin int    `json:"conn_max_lifetime_minutes"`
        } `json:"database"`
        Redis struct {
                Host string `json:"host"`
                Port string `json:"port"`
                DB   int    `json:"db"`
        } `json:"redis"`
        JWT struct {
                ExpireHours int `json:"expire_hours"`
        } `json:"jwt"`
        Log struct {
                Level string `json:"level"`
                File  string `json:"file"`
        } `json:"log"`
        Upload struct {
                Dir     string   `json:"dir"`
                MaxSize int64    `json:"max_size"`
                Exts    []string `json:"exts"`
        } `json:"upload"`
}

// SystemConfig 返回当前运行时的系统配置（只读，敏感字段已脱敏）
func (h *AdminHandler) SystemConfig(c *gin.Context) <span class="cov0" title="0">{
        cfg := config.AppConfig
        if cfg == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, "config not loaded"))
                return
        }</span>

        <span class="cov0" title="0">var info SystemConfigInfo
        info.Server.Host = cfg.Server.Host
        info.Server.Port = cfg.Server.Port
        info.Server.Mode = cfg.Server.Mode

        info.Database.Host = cfg.Database.Host
        info.Database.Port = cfg.Database.Port
        info.Database.User = cfg.Database.User
        info.Database.Name = cfg.Database.Name
        info.Database.MaxOpenConns = cfg.Database.MaxOpenConns
        info.Database.MaxIdleConns = cfg.Database.MaxIdleConns
        info.Database.ConnMaxLifetimeMin = cfg.Database.ConnMaxLifetimeMinutes

        info.Redis.Host = cfg.Redis.Host
        info.Redis.Port = cfg.Redis.Port
        info.Redis.DB = cfg.Redis.DB

        info.JWT.ExpireHours = cfg.JWT.ExpireHours

        info.Log.Level = cfg.Log.Level
        info.Log.File = cfg.Log.File

        info.Upload.Dir = cfg.Upload.Dir
        info.Upload.MaxSize = cfg.Upload.MaxSize
        info.Upload.Exts = cfg.Upload.AllowedExts

        c.JSON(http.StatusOK, models.Success(info))</span>
}


</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type ArticleHandler struct {
        articleService *services.ArticleService
}

func NewArticleHandler(articleService *services.ArticleService) *ArticleHandler <span class="cov0" title="0">{
        return &amp;ArticleHandler{
                articleService: articleService,
        }
}</span>

func (h *ArticleHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        <span class="cov0" title="0">var req models.ArticleCreate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        // 非管理员创建文章时不允许直接发布，只能是草稿或待审核
        <span class="cov0" title="0">if roleVal, ok := c.Get("role"); ok </span><span class="cov0" title="0">{
                if roleStr, ok2 := roleVal.(string); ok2 &amp;&amp; roleStr != string(models.RoleAdmin) </span><span class="cov0" title="0">{
                        if req.Status == models.StatusReview </span>{<span class="cov0" title="0">
                                // 保留“待审核”状态
                        }</span> else<span class="cov0" title="0"> {
                                // 其余情况一律归为草稿
                                req.Status = models.StatusDraft
                        }</span>
                }
        }

        <span class="cov0" title="0">article, err := h.articleService.Create(userID.(uuid.UUID), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(article))</span>
}

func (h *ArticleHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">article, err := h.articleService.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(article))</span>
}

func (h *ArticleHandler) GetBySlug(c *gin.Context) <span class="cov0" title="0">{
        slug := c.Param("slug")
        
        article, err := h.articleService.GetBySlug(slug)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(article))</span>
}

func (h *ArticleHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">var req models.ArticleUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        // 非管理员更新文章时不允许自行改为已发布 / 归档，仅允许草稿或待审核
        <span class="cov0" title="0">if roleVal, ok := c.Get("role"); ok &amp;&amp; req.Status != nil </span><span class="cov0" title="0">{
                if roleStr, ok2 := roleVal.(string); ok2 &amp;&amp; roleStr != string(models.RoleAdmin) </span><span class="cov0" title="0">{
                        if *req.Status == models.StatusReview || *req.Status == models.StatusDraft </span>{<span class="cov0" title="0">
                                // 保留可允许的状态
                        }</span> else<span class="cov0" title="0"> {
                                // 其余状态重置为草稿
                                draft := models.StatusDraft
                                req.Status = &amp;draft
                        }</span>
                }
        }

        <span class="cov0" title="0">article, err := h.articleService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(article))</span>
}

func (h *ArticleHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.articleService.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

func (h *ArticleHandler) Like(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.articleService.Like(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

func (h *ArticleHandler) List(c *gin.Context) <span class="cov0" title="0">{
        var query models.ArticleQuery
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        // 公开文章列表：默认只展示已发布文章
        <span class="cov0" title="0">if query.Status == "" </span><span class="cov0" title="0">{
                query.Status = models.StatusPublished
        }</span>

        // 全文搜索已完全使用Elasticsearch
        // 如果提供了search参数，会自动使用Elasticsearch搜索
        <span class="cov0" title="0">articles, total, err := h.articleService.List(query)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Paginated(articles, query.Page, query.PageSize, total))</span>
}

// AdminList 管理后台文章列表：包含所有状态、支持按作者/状态/搜索过滤
func (h *ArticleHandler) AdminList(c *gin.Context) <span class="cov0" title="0">{
        var query models.ArticleQuery
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">articles, total, err := h.articleService.List(query)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Paginated(articles, query.Page, query.PageSize, total))</span>
}

// AdminGetByID 管理后台查看文章详情（与公开详情相同，预留后续扩展）
func (h *ArticleHandler) AdminGetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">article, err := h.articleService.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(article))</span>
}

// AdminUpdateStatus 管理后台修改文章状态（草稿/发布/归档）
func (h *ArticleHandler) AdminUpdateStatus(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">var payload struct {
                Status models.ArticleStatus `json:"status"`
        }
        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">req := models.ArticleUpdate{
                Status: &amp;payload.Status,
        }

        article, err := h.articleService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(article))</span>
}

// AdminDelete 管理后台删除文章（复用已有删除逻辑）
func (h *ArticleHandler) AdminDelete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.articleService.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type CategoryHandler struct {
        categoryService *services.CategoryService
}

func NewCategoryHandler(categoryService *services.CategoryService) *CategoryHandler <span class="cov0" title="0">{
        return &amp;CategoryHandler{
                categoryService: categoryService,
        }
}</span>

func (h *CategoryHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var req models.CategoryCreate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.Create(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(category))</span>
}

func (h *CategoryHandler) List(c *gin.Context) <span class="cov0" title="0">{
        categories, err := h.categoryService.List()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(categories))</span>
}

// GetByID 获取分类详情（管理后台使用）
func (h *CategoryHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid category id"))
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(category))</span>
}

// Update 更新分类（管理后台使用）
func (h *CategoryHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid category id"))
                return
        }</span>

        <span class="cov0" title="0">var req models.CategoryUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(category))</span>
}

// Delete 删除分类（管理后台使用）
func (h *CategoryHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid category id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.categoryService.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type CommentHandler struct {
        commentService *services.CommentService
}

func NewCommentHandler(commentService *services.CommentService) *CommentHandler <span class="cov0" title="0">{
        return &amp;CommentHandler{
                commentService: commentService,
        }
}</span>

func (h *CommentHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var userID *uuid.UUID
        if uid, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                id := uid.(uuid.UUID)
                userID = &amp;id
        }</span>

        <span class="cov0" title="0">var req models.CommentCreate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">ip := c.ClientIP()
        comment, err := h.commentService.Create(userID, ip, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(comment))</span>
}

func (h *CommentHandler) GetByArticleID(c *gin.Context) <span class="cov0" title="0">{
        // 路由为 /articles/:id/comments，这里从参数 id 读取文章 ID
        articleID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid article id"))
                return
        }</span>

        <span class="cov0" title="0">var query struct {
                Page     int `form:"page"`
                PageSize int `form:"page_size"`
        }

        c.ShouldBindQuery(&amp;query)

        comments, total, err := h.commentService.GetByArticleID(articleID, query.Page, query.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Paginated(comments, query.Page, query.PageSize, total))</span>
}

func (h *CommentHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid comment id"))
                return
        }</span>

        <span class="cov0" title="0">var req models.CommentUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">comment, err := h.commentService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(comment))</span>
}

func (h *CommentHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid comment id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.commentService.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

</pre>
		
		<pre class="file" id="file9" style="display: none">// Package handlers 提供HTTP处理器
package handlers

import (
        "net/http"
        "os"
        "path/filepath"
        "strings"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ImageHandler 图片处理器
type ImageHandler struct {
        imageService *services.ImageService
}

// NewImageHandler 创建新的图片处理器实例
func NewImageHandler(imageService *services.ImageService) *ImageHandler <span class="cov0" title="0">{
        return &amp;ImageHandler{
                imageService: imageService,
        }
}</span>

// Upload 上传图片
// POST /api/v1/images/upload
// 需要认证
// Content-Type: multipart/form-data
// 表单字段:
//   - file: 图片文件（必需）
//   - description: 图片描述（可选）
//   - tags: 图片标签，逗号分隔（可选）
func (h *ImageHandler) Upload(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        // 获取上传的文件
        <span class="cov0" title="0">file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "file is required"))
                return
        }</span>

        // 获取描述和标签
        <span class="cov0" title="0">description := c.PostForm("description")
        tagsStr := c.PostForm("tags")
        var tags []string
        if tagsStr != "" </span><span class="cov0" title="0">{
                tags = strings.Split(tagsStr, ",")
                for i := range tags </span><span class="cov0" title="0">{
                        tags[i] = strings.TrimSpace(tags[i])
                }</span>
        }

        // 上传图片
        <span class="cov0" title="0">image, err := h.imageService.Upload(c.Request.Context(), userID.(uuid.UUID), file, description, tags)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(image))</span>
}

// GetByID 根据ID获取图片详情
// GET /api/v1/images/:id
func (h *ImageHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid image id"))
                return
        }</span>

        <span class="cov0" title="0">image, err := h.imageService.GetByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(image))</span>
}

// List 获取图片列表
// GET /api/v1/images?page=1&amp;page_size=20&amp;uploader_id=xxx&amp;search=keyword&amp;tag=tag1
func (h *ImageHandler) List(c *gin.Context) <span class="cov0" title="0">{
        var query models.ImageQuery
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">images, total, err := h.imageService.List(c.Request.Context(), query)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Paginated(images, query.Page, query.PageSize, total))</span>
}

// Update 更新图片信息
// PUT /api/v1/images/:id
// 需要认证
func (h *ImageHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid image id"))
                return
        }</span>

        // 检查权限：只能更新自己上传的图片
        <span class="cov0" title="0">userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        // 验证图片所有权
        <span class="cov0" title="0">image, err := h.imageService.GetByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        // 非管理员只能更新自己上传的图片
        <span class="cov0" title="0">if roleVal, ok := c.Get("role"); ok </span><span class="cov0" title="0">{
                roleStr, _ := roleVal.(string)
                if roleStr != string(models.RoleAdmin) &amp;&amp; image.UploaderID != userID.(uuid.UUID) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, models.Error(403, "forbidden: can only update your own images"))
                        return
                }</span>
        }

        <span class="cov0" title="0">var req models.ImageUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">updated, err := h.imageService.Update(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(updated))</span>
}

// Delete 删除图片
// DELETE /api/v1/images/:id
// 需要认证
func (h *ImageHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid image id"))
                return
        }</span>

        // 检查权限：只能删除自己上传的图片
        <span class="cov0" title="0">userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        // 验证图片所有权
        <span class="cov0" title="0">image, err := h.imageService.GetByID(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        // 非管理员只能删除自己上传的图片
        <span class="cov0" title="0">if roleVal, ok := c.Get("role"); ok </span><span class="cov0" title="0">{
                roleStr, _ := roleVal.(string)
                if roleStr != string(models.RoleAdmin) &amp;&amp; image.UploaderID != userID.(uuid.UUID) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, models.Error(403, "forbidden: can only delete your own images"))
                        return
                }</span>
        }

        <span class="cov0" title="0">if err := h.imageService.Delete(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

// ServeImage 提供图片文件服务
// GET /uploads/images/:filename
// 用于直接访问上传的图片文件
func (h *ImageHandler) ServeImage(c *gin.Context) <span class="cov0" title="0">{
        filename := c.Param("filename")
        
        // 安全检查：防止路径遍历攻击
        if strings.Contains(filename, "..") || strings.Contains(filename, "/") </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid filename"))
                return
        }</span>

        // 构建文件路径
        <span class="cov0" title="0">filePath := filepath.Join(h.imageService.GetUploadDir(), filename)
        
        // 检查文件是否存在
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, "image not found"))
                return
        }</span>

        // 返回文件
        <span class="cov0" title="0">c.File(filePath)</span>
}

</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type TagHandler struct {
        tagService *services.TagService
}

func NewTagHandler(tagService *services.TagService) *TagHandler <span class="cov0" title="0">{
        return &amp;TagHandler{
                tagService: tagService,
        }
}</span>

func (h *TagHandler) Create(c *gin.Context) <span class="cov0" title="0">{
        var req models.TagCreate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.Create(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(tag))</span>
}

func (h *TagHandler) List(c *gin.Context) <span class="cov0" title="0">{
        tags, err := h.tagService.List()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(tags))</span>
}

// GetByID 获取标签详情（管理后台使用）
func (h *TagHandler) GetByID(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid tag id"))
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(tag))</span>
}

// Update 更新标签（管理后台使用）
func (h *TagHandler) Update(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid tag id"))
                return
        }</span>

        <span class="cov0" title="0">var req models.TagUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(tag))</span>
}

// Delete 删除标签（管理后台使用）
func (h *TagHandler) Delete(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid tag id"))
                return
        }</span>

        <span class="cov0" title="0">if err := h.tagService.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "net/http"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/services"
        "enterprise-blog/pkg/jwt"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/google/uuid"
)

type UserHandler struct {
        userService *services.UserService
        smsService *services.SMSService
        jwtMgr      *jwt.JWTManager
        validator   *validator.Validate
}

func NewUserHandler(userService *services.UserService, smsService *services.SMSService, jwtMgr *jwt.JWTManager) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
                smsService:  smsService,
                jwtMgr:      jwtMgr,
                validator:   validator.New(),
        }
}</span>

func (h *UserHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req models.UserCreate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, models.Success(user))</span>
}

func (h *UserHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req models.UserLogin
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">token, user, err := h.userService.Login(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(map[string]interface{}{
                "token": token,
                "user":  user,
        }))</span>
}

func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetByID(userID.(uuid.UUID))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(user))</span>
}

func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UserUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.Update(userID.(uuid.UUID), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(user))</span>
}

// ChangePassword 修改当前登录用户密码
func (h *UserHandler) ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "unauthorized"))
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                OldPassword string `json:"old_password" validate:"required"`
                NewPassword string `json:"new_password" validate:"required,min=6"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.userService.ChangePassword(userID.(uuid.UUID), req.OldPassword, req.NewPassword); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(nil))</span>
}

func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid user id"))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, models.Error(404, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(user))</span>
}

func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        var query struct {
                Page     int `form:"page"`
                PageSize int `form:"page_size"`
        }

        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">users, total, err := h.userService.List(query.Page, query.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Paginated(users, query.Page, query.PageSize, total))</span>
}

// AdminUpdateUser 仅管理员可用，用于更新任意用户的角色 / 状态等信息
func (h *UserHandler) AdminUpdateUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, "invalid user id"))
                return
        }</span>

        <span class="cov0" title="0">var req models.UserUpdate
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.Update(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(user))</span>
}

// SendSMSCode 发送短信验证码
func (h *UserHandler) SendSMSCode(c *gin.Context) <span class="cov0" title="0">{
        var req models.SendSMSCodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.smsService.SendCode(req.Phone); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.Success(map[string]interface{}{
                "message": "验证码已发送",
        }))</span>
}

// LoginWithPhone 手机号验证码登录
func (h *UserHandler) LoginWithPhone(c *gin.Context) <span class="cov0" title="0">{
        var req models.PhoneLogin
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.Error(400, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.smsService.VerifyCode(req.Phone, req.Code)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, err.Error()))
                return
        }</span>

        // 检查用户状态
        <span class="cov0" title="0">if user.Status != "active" </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, models.Error(401, "user account is not active"))
                return
        }</span>

        // 生成 JWT token
        <span class="cov0" title="0">token, err := h.jwtMgr.GenerateToken(user.ID, user.Username, string(user.Role))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, models.Error(500, "failed to generate token"))
                return
        }</span>

        // 清除密码
        <span class="cov0" title="0">user.Password = ""

        c.JSON(http.StatusOK, models.Success(map[string]interface{}{
                "token": token,
                "user":  user,
        }))</span>
}

</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "enterprise-blog/internal/models"
        "enterprise-blog/pkg/jwt"

        "github.com/gin-gonic/gin"
)

func AuthMiddleware(jwtMgr *jwt.JWTManager) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, models.Error(401, "authorization header required"))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, models.Error(401, "invalid authorization header format"))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token := parts[1]
                claims, err := jwtMgr.ValidateToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, models.Error(401, "invalid token"))
                        c.Abort()
                        return
                }</span>

                // 将用户信息存储到上下文
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("username", claims.Username)
                c.Set("role", claims.Role)

                c.Next()</span>
        }
}

func RoleMiddleware(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role, exists := c.Get("role")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, models.Error(403, "role not found"))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">roleStr := role.(string)
                for _, r := range roles </span><span class="cov0" title="0">{
                        if roleStr == r </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.JSON(http.StatusForbidden, models.Error(403, "insufficient permissions"))
                c.Abort()</span>
        }
}

</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "net/http"
        "os"
        "strings"

        "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        allowedOrigins := map[string]struct{}{
                "http://localhost:3000": {},
                "http://127.0.0.1:3000": {},
                "http://localhost:5173": {},
                "http://127.0.0.1:5173": {},
        }

        if extra := os.Getenv("CORS_ALLOWED_ORIGINS"); extra != "" </span><span class="cov0" title="0">{
                for _, o := range strings.Split(extra, ",") </span><span class="cov0" title="0">{
                        o = strings.TrimSpace(o)
                        if o != "" </span><span class="cov0" title="0">{
                                allowedOrigins[o] = struct{}{}
                        }</span>
                }
        }

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")
                if origin != "" </span><span class="cov0" title="0">{
                        if _, ok := allowedOrigins[origin]; ok </span><span class="cov0" title="0">{
                                c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
                                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                                c.Writer.Header().Set("Vary", "Origin")
                        }</span>
                }

                <span class="cov0" title="0">c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, PATCH")
                c.Writer.Header().Set("Access-Control-Max-Age", "86400")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "time"

        "enterprise-blog/pkg/logger"

        "github.com/gin-gonic/gin"
)

func LoggerMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                path := c.Request.URL.Path
                raw := c.Request.URL.RawQuery

                c.Next()

                latency := time.Since(start)
                status := c.Writer.Status()
                clientIP := c.ClientIP()
                method := c.Request.Method
                errorMessage := c.Errors.ByType(gin.ErrorTypePrivate).String()

                l := logger.GetLogger()
                event := l.Info()
                if len(errorMessage) &gt; 0 </span><span class="cov0" title="0">{
                        event = l.Error()
                }</span>

                <span class="cov0" title="0">if raw != "" </span><span class="cov0" title="0">{
                        path = path + "?" + raw
                }</span>

                <span class="cov0" title="0">event.
                        Str("method", method).
                        Str("path", path).
                        Int("status", status).
                        Str("ip", clientIP).
                        Dur("latency", latency).
                        Str("user_agent", c.Request.UserAgent()).
                        Msg("HTTP Request")

                // 5xx 错误额外记一条错误日志
                if status &gt;= 500 </span><span class="cov0" title="0">{
                        l2 := logger.GetLogger()
                        l2.Error().
                                Str("method", method).
                                Str("path", path).
                                Int("status", status).
                                Str("error", errorMessage).
                                Msg("HTTP Error")
                }</span>
        }
}

</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/gin-gonic/gin"
)

func RateLimitMiddleware(limit int, window time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()
                key := fmt.Sprintf("ratelimit:%s:%s", clientIP, c.Request.URL.Path)

                ctx := context.Background()
                
                // 获取当前计数
                count, err := database.RedisClient.Get(ctx, key).Int()
                if err != nil &amp;&amp; err.Error() != "redis: nil" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">if count &gt;= limit </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, models.Error(429, "too many requests"))
                        c.Abort()
                        return
                }</span>

                // 增加计数
                <span class="cov0" title="0">pipe := database.RedisClient.Pipeline()
                pipe.Incr(ctx, key)
                pipe.Expire(ctx, key, window)
                _, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // 设置响应头
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
                c.Header("X-RateLimit-Remaining", strconv.Itoa(limit-count-1))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(window).Unix(), 10))

                c.Next()</span>
        }
}

</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "database/sql/driver"
        "errors"
        "time"

        "github.com/google/uuid"
)

type ArticleStatus string

const (
        StatusDraft        ArticleStatus = "draft"
        StatusReview       ArticleStatus = "review"
        StatusPublished    ArticleStatus = "published"
        StatusArchived     ArticleStatus = "archived"
)

type Article struct {
        ID           uuid.UUID     `json:"id" db:"id"`
        Title        string        `json:"title" db:"title"`
        Slug         string        `json:"slug" db:"slug"`
        Content      string        `json:"content" db:"content"`
        Excerpt      string        `json:"excerpt" db:"excerpt"`
        CoverImage   string        `json:"cover_image" db:"cover_image"`
        Status       ArticleStatus `json:"status" db:"status"`
        AuthorID     uuid.UUID     `json:"author_id" db:"author_id"`
        Author       *User         `json:"author,omitempty"`
        CategoryID   *uuid.UUID    `json:"category_id,omitempty" db:"category_id"`
        Category     *Category     `json:"category,omitempty"`
        // Tags 由单独的查询加载，不通过 GORM 关系映射
        Tags         []Tag         `json:"tags,omitempty" gorm:"-"`
        ViewCount    int           `json:"view_count" db:"view_count"`
        LikeCount    int           `json:"like_count" db:"like_count"`
        CommentCount int           `json:"comment_count" db:"comment_count"`
        PublishedAt  *time.Time    `json:"published_at,omitempty" db:"published_at"`
        CreatedAt    time.Time     `json:"created_at" db:"created_at"`
        UpdatedAt    time.Time     `json:"updated_at" db:"updated_at"`
        DeletedAt    *time.Time    `json:"deleted_at,omitempty" db:"deleted_at"`
}

type ArticleCreate struct {
        Title      string        `json:"title" validate:"required,min=1,max=200"`
        Content    string        `json:"content" validate:"required"`
        Excerpt    string        `json:"excerpt"`
        CoverImage string        `json:"cover_image"`
        Status     ArticleStatus `json:"status"`
        CategoryID *uuid.UUID    `json:"category_id"`
        TagIDs     []uuid.UUID   `json:"tag_ids"`
}

type ArticleUpdate struct {
        Title      *string        `json:"title,omitempty" validate:"omitempty,min=1,max=200"`
        Content    *string        `json:"content,omitempty"`
        Excerpt    *string        `json:"excerpt,omitempty"`
        CoverImage *string        `json:"cover_image,omitempty"`
        Status     *ArticleStatus `json:"status,omitempty"`
        CategoryID *uuid.UUID     `json:"category_id,omitempty"`
        TagIDs     []uuid.UUID    `json:"tag_ids,omitempty"`
}

type ArticleQuery struct {
        Page       int           `form:"page"`
        PageSize   int           `form:"page_size"`
        Status     ArticleStatus `form:"status"`
        CategoryID *uuid.UUID    `form:"category_id"`
        TagID      *uuid.UUID    `form:"tag_id"`
        AuthorID   *uuid.UUID    `form:"author_id"`
        Search     string        `form:"search"`
        SortBy     string        `form:"sort_by"`
        Order      string        `form:"order"`
}

func (s ArticleStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        return string(s), nil
}</span>

func (s *ArticleStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *s = StatusDraft
                return nil
        }</span>
        <span class="cov0" title="0">if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                *s = ArticleStatus(str)
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("cannot scan ArticleStatus")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

type Response struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
}

type PaginationResponse struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data"`
        Meta    PaginationMeta `json:"meta"`
}

type PaginationMeta struct {
        Page      int   `json:"page"`
        PageSize  int   `json:"page_size"`
        Total     int64 `json:"total"`
        TotalPage int   `json:"total_page"`
}

func Success(data interface{}) *Response <span class="cov0" title="0">{
        return &amp;Response{
                Code:    200,
                Message: "success",
                Data:    data,
        }
}</span>

func SuccessWithMessage(message string, data interface{}) *Response <span class="cov0" title="0">{
        return &amp;Response{
                Code:    200,
                Message: message,
                Data:    data,
        }
}</span>

func Error(code int, message string) *Response <span class="cov0" title="0">{
        return &amp;Response{
                Code:    code,
                Message: message,
        }
}</span>

func Paginated(data interface{}, page, pageSize int, total int64) *PaginationResponse <span class="cov0" title="0">{
        totalPage := int(total) / pageSize
        if int(total)%pageSize &gt; 0 </span><span class="cov0" title="0">{
                totalPage++
        }</span>
        
        <span class="cov0" title="0">return &amp;PaginationResponse{
                Code:    200,
                Message: "success",
                Data:    data,
                Meta: PaginationMeta{
                        Page:      page,
                        PageSize:  pageSize,
                        Total:     total,
                        TotalPage: totalPage,
                },
        }</span>
}

</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "database/sql/driver"
        "errors"
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type UserRole string

const (
        RoleAdmin  UserRole = "admin"
        RoleEditor UserRole = "editor"
        RoleAuthor UserRole = "author"
        RoleReader UserRole = "reader"
)

type User struct {
        ID        uuid.UUID  `json:"id" db:"id"`
        Username  string     `json:"username" db:"username"`
        Email     string     `json:"email" db:"email"`
        Phone     string     `json:"phone,omitempty" db:"phone"`
        Password  string     `json:"-" db:"password"`
        Role      UserRole   `json:"role" db:"role"`
        Avatar    string     `json:"avatar" db:"avatar"`
        Bio       string     `json:"bio" db:"bio"`
        Status    string     `json:"status" db:"status"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

type UserCreate struct {
        Username string   `json:"username" validate:"required,min=3,max=50"`
        Email    string   `json:"email" validate:"required,email"`
        Password string   `json:"password" validate:"required,min=6"`
        Role     UserRole `json:"role"`
}

type UserUpdate struct {
        Username *string   `json:"username,omitempty" validate:"omitempty,min=3,max=50"`
        Email    *string   `json:"email,omitempty" validate:"omitempty,email"`
        Role     *UserRole `json:"role,omitempty"`
        Avatar   *string   `json:"avatar,omitempty"`
        Bio      *string   `json:"bio,omitempty"`
        Status   *string   `json:"status,omitempty"`
}

type UserLogin struct {
        Email    string `json:"email" validate:"required,email"`
        Password string `json:"password" validate:"required"`
}

type PhoneLogin struct {
        Phone string `json:"phone" validate:"required"`
        Code  string `json:"code" validate:"required,len=6"`
}

type SendSMSCodeRequest struct {
        Phone string `json:"phone" validate:"required"`
}

func (u *User) HashPassword() error <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u.Password = string(hashedPassword)
        return nil</span>
}

func (u *User) CheckPassword(password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        return err == nil
}</span>

func (r UserRole) Value() (driver.Value, error) <span class="cov0" title="0">{
        return string(r), nil
}</span>

func (r *UserRole) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *r = RoleReader
                return nil
        }</span>
        <span class="cov0" title="0">if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                *r = UserRole(str)
                return nil
        }</span>
        <span class="cov0" title="0">return errors.New("cannot scan UserRole")</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
        "gorm.io/gorm"
)

type ArticleRepository struct{}

func NewArticleRepository() *ArticleRepository <span class="cov0" title="0">{
        return &amp;ArticleRepository{}
}</span>

func (r *ArticleRepository) Create(ctx context.Context, article *models.Article) error <span class="cov0" title="0">{
        tx := database.DB.WithContext(ctx).Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">query := `
                INSERT INTO articles (id, title, slug, content, excerpt, cover_image, status, author_id, category_id, view_count, like_count, comment_count, published_at, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
                RETURNING id
        `
        
        now := time.Now()
        article.ID = uuid.New()
        article.CreatedAt = now
        article.UpdatedAt = now
        if article.Status == models.StatusPublished &amp;&amp; article.PublishedAt == nil </span><span class="cov0" title="0">{
                article.PublishedAt = &amp;now
        }</span>

        <span class="cov0" title="0">row := tx.Raw(
                query,
                article.ID, article.Title, article.Slug, article.Content, article.Excerpt,
                article.CoverImage, article.Status, article.AuthorID, article.CategoryID,
                article.ViewCount, article.LikeCount, article.CommentCount,
                article.PublishedAt, article.CreatedAt, article.UpdatedAt,
        ).Row()
        if err := row.Scan(&amp;article.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *ArticleRepository) GetByID(id uuid.UUID) (*models.Article, error) <span class="cov0" title="0">{
        // 默认使用背景上下文，以兼容旧调用；推荐通过带 ctx 的方法调用
        ctx := context.Background()
        return r.GetByIDWithContext(ctx, id)
}</span>

func (r *ArticleRepository) GetByIDWithContext(ctx context.Context, id uuid.UUID) (*models.Article, error) <span class="cov0" title="0">{
        article := &amp;models.Article{}
        query := `
                SELECT a.id, a.title, a.slug, a.content, a.excerpt, a.cover_image, a.status,
                           a.author_id, a.category_id, a.view_count, a.like_count, a.comment_count,
                           a.published_at, a.created_at, a.updated_at, a.deleted_at
                FROM articles a
                WHERE a.id = $1 AND a.deleted_at IS NULL
        `

        result := database.DB.WithContext(ctx).Raw(query, id).Scan(article)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("article not found")
        }</span>

        // 加载作者信息
        <span class="cov0" title="0">if err := r.loadArticleRelations(article); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return article, nil</span>
}

func (r *ArticleRepository) GetBySlug(slug string) (*models.Article, error) <span class="cov0" title="0">{
        ctx := context.Background()
        return r.GetBySlugWithContext(ctx, slug)
}</span>

func (r *ArticleRepository) GetBySlugWithContext(ctx context.Context, slug string) (*models.Article, error) <span class="cov0" title="0">{
        article := &amp;models.Article{}
        query := `
                SELECT a.id, a.title, a.slug, a.content, a.excerpt, a.cover_image, a.status,
                           a.author_id, a.category_id, a.view_count, a.like_count, a.comment_count,
                           a.published_at, a.created_at, a.updated_at, a.deleted_at
                FROM articles a
                WHERE a.slug = $1 AND a.deleted_at IS NULL
        `

        result := database.DB.WithContext(ctx).Raw(query, slug).Scan(article)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("article not found")
        }</span>

        <span class="cov0" title="0">if err := r.loadArticleRelations(article); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return article, nil</span>
}

func (r *ArticleRepository) Update(article *models.Article) error <span class="cov0" title="0">{
        ctx := context.Background()
        tx := database.DB.WithContext(ctx).Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">query := `
                UPDATE articles 
                SET title = $2, slug = $3, content = $4, excerpt = $5, cover_image = $6,
                        status = $7, category_id = $8, updated_at = $9, published_at = $10
                WHERE id = $1 AND deleted_at IS NULL
        `
        
        article.UpdatedAt = time.Now()
        if article.Status == models.StatusPublished &amp;&amp; article.PublishedAt == nil </span><span class="cov0" title="0">{
                now := time.Now()
                article.PublishedAt = &amp;now
        }</span>

        <span class="cov0" title="0">result := tx.Exec(query, article.ID, article.Title, article.Slug, article.Content,
                article.Excerpt, article.CoverImage, article.Status, article.CategoryID,
                article.UpdatedAt, article.PublishedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("article not found")
        }</span>

        // 更新标签关联
        <span class="cov0" title="0">if len(article.Tags) &gt; 0 </span><span class="cov0" title="0">{
                // 删除旧关联
                if err := tx.Exec("DELETE FROM article_tags WHERE article_id = $1", article.ID).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // 创建新关联
                <span class="cov0" title="0">if err := r.setArticleTags(tx, article.ID, article.Tags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *ArticleRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        ctx := context.Background()
        query := `UPDATE articles SET deleted_at = $1 WHERE id = $2 AND deleted_at IS NULL`
        result := database.DB.WithContext(ctx).Exec(query, time.Now(), id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("article not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ArticleRepository) List(ctx context.Context, query models.ArticleQuery) ([]*models.Article, int64, error) <span class="cov0" title="0">{
        var articles []*models.Article
        var total int64

        if query.Page &lt;= 0 </span><span class="cov0" title="0">{
                query.Page = 1
        }</span>
        <span class="cov0" title="0">if query.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                query.PageSize = 10
        }</span>
        <span class="cov0" title="0">offset := (query.Page - 1) * query.PageSize

        // 构建查询条件
        where := []string{"a.deleted_at IS NULL"}
        args := []interface{}{}

        if query.Status != "" </span><span class="cov0" title="0">{
                where = append(where, "a.status = ?")
                args = append(args, query.Status)
        }</span>

        <span class="cov0" title="0">if query.CategoryID != nil </span><span class="cov0" title="0">{
                where = append(where, "a.category_id = ?")
                args = append(args, *query.CategoryID)
        }</span>

        <span class="cov0" title="0">if query.AuthorID != nil </span><span class="cov0" title="0">{
                where = append(where, "a.author_id = ?")
                args = append(args, *query.AuthorID)
        }</span>

        // 注意：全文搜索已完全迁移到Elasticsearch
        // 如果query.Search不为空，应该在Service层使用Elasticsearch搜索
        // 这里不再处理Search条件，只处理其他筛选条件

        <span class="cov0" title="0">if query.TagID != nil </span><span class="cov0" title="0">{
                where = append(where, "EXISTS (SELECT 1 FROM article_tags WHERE article_id = a.id AND tag_id = ?)")
                args = append(args, *query.TagID)
        }</span>

        <span class="cov0" title="0">whereClause := strings.Join(where, " AND ")

        // 获取总数 - 使用参数化查询，避免 SQL 注入
        countQuery := "SELECT COUNT(*) FROM articles a WHERE " + whereClause
        err := database.DB.WithContext(ctx).Raw(countQuery, args...).Scan(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 排序 - 使用白名单验证，防止 SQL 注入
        <span class="cov0" title="0">var orderBy string
        // 白名单：允许的排序字段
        allowedSortFields := map[string]string{
                "id":          "a.id",
                "title":       "a.title",
                "created_at":  "a.created_at",
                "updated_at":  "a.updated_at",
                "published_at": "a.published_at",
                "view_count":  "a.view_count",
                "like_count":  "a.like_count",
                "comment_count": "a.comment_count",
        }

        // 白名单：允许的排序方向
        allowedOrders := map[string]bool{
                "asc":  true,
                "desc": true,
        }

        // 验证并构建 ORDER BY 子句
        if query.SortBy != "" </span><span class="cov0" title="0">{
                sortField, ok := allowedSortFields[query.SortBy]
                if !ok </span><span class="cov0" title="0">{
                        // 无效的排序字段，使用默认排序
                        orderBy = "a.created_at DESC"
                }</span> else<span class="cov0" title="0"> {
                        // 验证排序方向
                        order := strings.ToLower(query.Order)
                        if !allowedOrders[order] </span><span class="cov0" title="0">{
                                order = "desc" // 默认降序
                        }</span>
                        <span class="cov0" title="0">orderBy = fmt.Sprintf("%s %s", sortField, strings.ToUpper(order))</span>
                }
        } else<span class="cov0" title="0"> {
                // 默认按创建时间倒序
                orderBy = "a.created_at DESC"
        }</span>

        // 获取列表 - 使用参数化查询，避免 SQL 注入
        <span class="cov0" title="0">listQuery := fmt.Sprintf(`
                SELECT a.id, a.title, a.slug, a.content, a.excerpt, a.cover_image, a.status,
                           a.author_id, a.category_id, a.view_count, a.like_count, a.comment_count,
                           a.published_at, a.created_at, a.updated_at
                FROM articles a
                WHERE %s
                ORDER BY %s
                LIMIT ? OFFSET ?
        `, whereClause, orderBy)

        args = append(args, query.PageSize, offset)
        err = database.DB.WithContext(ctx).Raw(listQuery, args...).Scan(&amp;articles).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 加载关联数据
        <span class="cov0" title="0">for _, article := range articles </span><span class="cov0" title="0">{
                if err := r.loadArticleRelations(article); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
        }

        <span class="cov0" title="0">return articles, total, nil</span>
}

func (r *ArticleRepository) IncrementViewCount(id uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE articles SET view_count = view_count + 1 WHERE id = $1`
        return database.DB.Exec(query, id).Error
}</span>

func (r *ArticleRepository) IncrementLikeCount(id uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE articles SET like_count = like_count + 1 WHERE id = $1`
        return database.DB.Exec(query, id).Error
}</span>

func (r *ArticleRepository) setArticleTags(tx *gorm.DB, articleID uuid.UUID, tags []models.Tag) error <span class="cov0" title="0">{
        if len(tags) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tagIDs := make([]uuid.UUID, len(tags))
        for i, tag := range tags </span><span class="cov0" title="0">{
                tagIDs[i] = tag.ID
        }</span>

        <span class="cov0" title="0">query := `INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`
        for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                if err := tx.Exec(query, articleID, tagID).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AddTags 为文章添加标签（用于创建后追加标签）
func (r *ArticleRepository) AddTags(articleID uuid.UUID, tagIDs []uuid.UUID) error <span class="cov0" title="0">{
        if len(tagIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query := `INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`
        for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                if err := database.DB.Exec(query, articleID, tagID).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReplaceTags 替换文章的全部标签（用于更新）
func (r *ArticleRepository) ReplaceTags(articleID uuid.UUID, tagIDs []uuid.UUID) error <span class="cov0" title="0">{
        tx := database.DB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>
        <span class="cov0" title="0">if err := tx.Exec("DELETE FROM article_tags WHERE article_id = $1", articleID).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov0" title="0">if len(tagIDs) &gt; 0 </span><span class="cov0" title="0">{
                query := `INSERT INTO article_tags (article_id, tag_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`
                for _, tagID := range tagIDs </span><span class="cov0" title="0">{
                        if err := tx.Exec(query, articleID, tagID).Error; err != nil </span><span class="cov0" title="0">{
                                tx.Rollback()
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return tx.Commit().Error</span>
}

func (r *ArticleRepository) loadArticleRelations(article *models.Article) error <span class="cov0" title="0">{
        // 加载作者
        var author models.User
        err := database.DB.Raw("SELECT id, username, email, avatar FROM users WHERE id = $1", article.AuthorID).Scan(&amp;author).Error
        if err == nil </span><span class="cov0" title="0">{
                article.Author = &amp;author
        }</span>

        // 加载分类
        <span class="cov0" title="0">if article.CategoryID != nil </span><span class="cov0" title="0">{
                var category models.Category
                err := database.DB.Raw("SELECT id, name, slug FROM categories WHERE id = $1", *article.CategoryID).Scan(&amp;category).Error
                if err == nil </span><span class="cov0" title="0">{
                        article.Category = &amp;category
                }</span>
        }

        // 加载标签
        <span class="cov0" title="0">var tags []models.Tag
        err = database.DB.Raw(`
                SELECT t.id, t.name, t.slug, t.color
                FROM tags t
                INNER JOIN article_tags at ON t.id = at.tag_id
                WHERE at.article_id = $1
        `, article.ID).Scan(&amp;tags).Error
        if err == nil </span><span class="cov0" title="0">{
                article.Tags = tags
        }</span>

        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "database/sql"
        "errors"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

type CategoryRepository struct{}

func NewCategoryRepository() *CategoryRepository <span class="cov0" title="0">{
        return &amp;CategoryRepository{}
}</span>

func (r *CategoryRepository) Create(category *models.Category) error <span class="cov0" title="0">{
        query := `
                INSERT INTO categories (id, name, slug, description, parent_id, "order", created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id
        `
        
        now := time.Now()
        category.ID = uuid.New()
        category.CreatedAt = now
        category.UpdatedAt = now

        row := database.DB.Raw(
                query,
                category.ID, category.Name, category.Slug, category.Description,
                category.ParentID, category.Order, category.CreatedAt, category.UpdatedAt,
        ).Row()
        return row.Scan(&amp;category.ID)
}</span>

func (r *CategoryRepository) GetByID(id uuid.UUID) (*models.Category, error) <span class="cov0" title="0">{
        category := &amp;models.Category{}
        query := `SELECT id, name, slug, description, parent_id, "order", created_at, updated_at
                          FROM categories WHERE id = $1`
        
        err := database.DB.Raw(query, id).Scan(category).Error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>
        <span class="cov0" title="0">return category, err</span>
}

func (r *CategoryRepository) Update(category *models.Category) error <span class="cov0" title="0">{
        query := `
                UPDATE categories 
                SET name = $2, slug = $3, description = $4, parent_id = $5, "order" = $6, updated_at = $7
                WHERE id = $1
        `
        
        category.UpdatedAt = time.Now()
        result := database.DB.Exec(query, category.ID, category.Name, category.Slug,
                category.Description, category.ParentID, category.Order, category.UpdatedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("category not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CategoryRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM categories WHERE id = $1`
        result := database.DB.Exec(query, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("category not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CategoryRepository) List() ([]*models.Category, error) <span class="cov0" title="0">{
        var categories []*models.Category
        query := `SELECT id, name, slug, description, parent_id, "order", created_at, updated_at
                          FROM categories ORDER BY "order" ASC, created_at DESC`
        
        err := database.DB.Raw(query).Scan(&amp;categories).Error
        return categories, err
}</span>

</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "database/sql"
        "errors"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

type CommentRepository struct{}

func NewCommentRepository() *CommentRepository <span class="cov0" title="0">{
        return &amp;CommentRepository{}
}</span>

func (r *CommentRepository) Create(comment *models.Comment) error <span class="cov0" title="0">{
        query := `
                INSERT INTO comments (id, article_id, user_id, parent_id, content, author, email, website, ip, status, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                RETURNING id
        `
        
        now := time.Now()
        comment.ID = uuid.New()
        comment.CreatedAt = now
        comment.UpdatedAt = now
        if comment.Status == "" </span><span class="cov0" title="0">{
                comment.Status = "pending"
        }</span>

        <span class="cov0" title="0">row := database.DB.Raw(
                query,
                comment.ID, comment.ArticleID, comment.UserID, comment.ParentID,
                comment.Content, comment.Author, comment.Email, comment.Website,
                comment.IP, comment.Status, comment.CreatedAt, comment.UpdatedAt,
        ).Row()
        return row.Scan(&amp;comment.ID)</span>
}

func (r *CommentRepository) GetByID(id uuid.UUID) (*models.Comment, error) <span class="cov0" title="0">{
        comment := &amp;models.Comment{}
        query := `
                SELECT id, article_id, user_id, parent_id, content, author, email, website, ip, status, created_at, updated_at
                FROM comments WHERE id = $1
        `
        
        err := database.DB.Raw(query, id).Scan(comment).Error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.New("comment not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 加载用户信息
        <span class="cov0" title="0">if comment.UserID != nil </span><span class="cov0" title="0">{
                var user models.User
                err = database.DB.Raw("SELECT id, username, email, avatar FROM users WHERE id = $1", *comment.UserID).Scan(&amp;user).Error
                if err == nil </span><span class="cov0" title="0">{
                        comment.User = &amp;user
                }</span>
        }

        <span class="cov0" title="0">return comment, nil</span>
}

func (r *CommentRepository) GetByArticleID(articleID uuid.UUID, page, pageSize int) ([]*models.Comment, int64, error) <span class="cov0" title="0">{
        var comments []*models.Comment
        var total int64

        offset := (page - 1) * pageSize

        // 获取总数
        countQuery := `SELECT COUNT(*) FROM comments WHERE article_id = $1 AND parent_id IS NULL`
        err := database.DB.Raw(countQuery, articleID).Scan(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 获取父评论
        <span class="cov0" title="0">query := `
                SELECT id, article_id, user_id, parent_id, content, author, email, website, ip, status, created_at, updated_at
                FROM comments
                WHERE article_id = $1 AND parent_id IS NULL
                ORDER BY created_at DESC
                LIMIT $2 OFFSET $3
        `
        
        err = database.DB.Raw(query, articleID, pageSize, offset).Scan(&amp;comments).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 加载用户信息和子评论
        <span class="cov0" title="0">for i := range comments </span><span class="cov0" title="0">{
                if comments[i].UserID != nil </span><span class="cov0" title="0">{
                        var user models.User
                        err = database.DB.Raw("SELECT id, username, email, avatar FROM users WHERE id = $1", *comments[i].UserID).Scan(&amp;user).Error
                        if err == nil </span><span class="cov0" title="0">{
                                comments[i].User = &amp;user
                        }</span>
                }
        }

        <span class="cov0" title="0">return comments, total, nil</span>
}

func (r *CommentRepository) Update(comment *models.Comment) error <span class="cov0" title="0">{
        query := `
                UPDATE comments 
                SET content = $2, status = $3, updated_at = $4
                WHERE id = $1
        `
        
        comment.UpdatedAt = time.Now()
        result := database.DB.Exec(query, comment.ID, comment.Content, comment.Status, comment.UpdatedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("comment not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CommentRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM comments WHERE id = $1`
        result := database.DB.Exec(query, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("comment not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *CommentRepository) IncrementCommentCount(articleID uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE articles SET comment_count = comment_count + 1 WHERE id = $1`
        return database.DB.Exec(query, articleID).Error
}</span>

</pre>
		
		<pre class="file" id="file22" style="display: none">// Package repository 提供数据访问层的实现
package repository

import (
        "context"
        "database/sql"
        "errors"
        "strings"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

// ImageRepository 图片数据访问层，提供图片相关的数据库操作
type ImageRepository struct{}

// NewImageRepository 创建新的图片仓库实例
func NewImageRepository() *ImageRepository <span class="cov0" title="0">{
        return &amp;ImageRepository{}
}</span>

// Create 创建新图片记录
// image: 图片对象，会设置ID、创建时间、更新时间
// 返回: 如果创建失败则返回错误
func (r *ImageRepository) Create(ctx context.Context, image *models.Image) error <span class="cov0" title="0">{
        query := `
                INSERT INTO images (id, filename, original_name, path, url, mime_type, size, width, height, uploader_id, description, tags, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                RETURNING id
        `

        now := time.Now()
        image.ID = uuid.New()
        image.CreatedAt = now
        image.UpdatedAt = now

        // 将tags转换为JSONB格式
        tagsJSON := "[]"
        if len(image.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagsJSON = `["` + strings.Join(image.Tags, `","`) + `"]`
        }</span>

        <span class="cov0" title="0">row := database.DB.WithContext(ctx).Raw(
                query,
                image.ID, image.Filename, image.OriginalName, image.Path, image.URL,
                image.MimeType, image.Size, image.Width, image.Height, image.UploaderID,
                image.Description, tagsJSON, image.CreatedAt, image.UpdatedAt,
        ).Row()
        return row.Scan(&amp;image.ID)</span>
}

// GetByID 根据ID获取图片
// id: 图片UUID
// 返回: 图片对象，如果不存在则返回错误
func (r *ImageRepository) GetByID(ctx context.Context, id uuid.UUID) (*models.Image, error) <span class="cov0" title="0">{
        image := &amp;models.Image{}
        query := `
                SELECT id, filename, original_name, path, url, mime_type, size, width, height,
                       uploader_id, description, tags, created_at, updated_at, deleted_at
                FROM images
                WHERE id = $1 AND deleted_at IS NULL
        `

        err := database.DB.WithContext(ctx).Raw(query, id).Scan(image).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, errors.New("image not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 加载上传者信息
        <span class="cov0" title="0">if err := r.loadImageRelations(ctx, image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return image, nil</span>
}

// Update 更新图片信息
// image: 图片对象，会更新更新时间
// 返回: 如果更新失败或图片不存在则返回错误
func (r *ImageRepository) Update(ctx context.Context, image *models.Image) error <span class="cov0" title="0">{
        query := `
                UPDATE images
                SET description = $2, tags = $3, updated_at = $4
                WHERE id = $1 AND deleted_at IS NULL
        `

        image.UpdatedAt = time.Now()

        // 将tags转换为JSONB格式
        tagsJSON := "[]"
        if len(image.Tags) &gt; 0 </span><span class="cov0" title="0">{
                tagsJSON = `["` + strings.Join(image.Tags, `","`) + `"]`
        }</span>

        <span class="cov0" title="0">result := database.DB.WithContext(ctx).Exec(query, image.ID, image.Description, tagsJSON, image.UpdatedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("image not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete 删除图片（软删除）
// id: 图片UUID
// 返回: 如果删除失败或图片不存在则返回错误
func (r *ImageRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE images SET deleted_at = $1 WHERE id = $2 AND deleted_at IS NULL`
        result := database.DB.WithContext(ctx).Exec(query, time.Now(), id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("image not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List 获取图片列表（分页、筛选、搜索）
// ctx: 上下文
// query: 图片查询条件
// 返回: 图片列表、总数，如果查询失败则返回错误
func (r *ImageRepository) List(ctx context.Context, query models.ImageQuery) ([]*models.Image, int64, error) <span class="cov0" title="0">{
        var images []*models.Image
        var total int64

        if query.Page &lt;= 0 </span><span class="cov0" title="0">{
                query.Page = 1
        }</span>
        <span class="cov0" title="0">if query.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                query.PageSize = 20
        }</span>
        <span class="cov0" title="0">if query.PageSize &gt; 100 </span><span class="cov0" title="0">{
                query.PageSize = 100
        }</span>
        <span class="cov0" title="0">offset := (query.Page - 1) * query.PageSize

        // 构建查询条件
        where := []string{"deleted_at IS NULL"}
        args := []interface{}{}

        if query.UploaderID != nil </span><span class="cov0" title="0">{
                where = append(where, "uploader_id = ?")
                args = append(args, *query.UploaderID)
        }</span>

        <span class="cov0" title="0">if query.Search != "" </span><span class="cov0" title="0">{
                where = append(where, "to_tsvector('english', coalesce(filename, '') || ' ' || coalesce(description, '')) @@ to_tsquery('english', ?)")
                searchTerms := strings.Fields(query.Search)
                tsQuery := strings.Join(searchTerms, " &amp; ")
                args = append(args, tsQuery)
        }</span>

        <span class="cov0" title="0">if query.Tag != "" </span><span class="cov0" title="0">{
                where = append(where, "tags @&gt; ?::jsonb")
                tagJSON := `["` + query.Tag + `"]`
                args = append(args, tagJSON)
        }</span>

        <span class="cov0" title="0">whereClause := strings.Join(where, " AND ")

        // 获取总数
        countQuery := "SELECT COUNT(*) FROM images WHERE " + whereClause
        err := database.DB.WithContext(ctx).Raw(countQuery, args...).Scan(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 排序
        <span class="cov0" title="0">var orderBy string
        allowedSortFields := map[string]string{
                "id":          "id",
                "filename":    "filename",
                "created_at":  "created_at",
                "updated_at":  "updated_at",
                "size":        "size",
        }

        allowedOrders := map[string]bool{
                "asc":  true,
                "desc": true,
        }

        if query.SortBy != "" </span><span class="cov0" title="0">{
                sortField, ok := allowedSortFields[query.SortBy]
                if !ok </span><span class="cov0" title="0">{
                        orderBy = "created_at DESC"
                }</span> else<span class="cov0" title="0"> {
                        order := strings.ToLower(query.Order)
                        if !allowedOrders[order] </span><span class="cov0" title="0">{
                                order = "desc"
                        }</span>
                        <span class="cov0" title="0">orderBy = sortField + " " + strings.ToUpper(order)</span>
                }
        } else<span class="cov0" title="0"> {
                orderBy = "created_at DESC"
        }</span>

        // 获取列表
        <span class="cov0" title="0">listQuery := `
                SELECT id, filename, original_name, path, url, mime_type, size, width, height,
                       uploader_id, description, tags, created_at, updated_at
                FROM images
                WHERE ` + whereClause + `
                ORDER BY ` + orderBy + `
                LIMIT ? OFFSET ?
        `

        args = append(args, query.PageSize, offset)
        err = database.DB.WithContext(ctx).Raw(listQuery, args...).Scan(&amp;images).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 加载关联数据
        <span class="cov0" title="0">for _, image := range images </span><span class="cov0" title="0">{
                if err := r.loadImageRelations(ctx, image); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
        }

        <span class="cov0" title="0">return images, total, nil</span>
}

// loadImageRelations 加载图片关联数据（上传者信息）
func (r *ImageRepository) loadImageRelations(ctx context.Context, image *models.Image) error <span class="cov0" title="0">{
        var uploader models.User
        err := database.DB.WithContext(ctx).Raw(
                "SELECT id, username, email, avatar FROM users WHERE id = $1",
                image.UploaderID,
        ).Scan(&amp;uploader).Error
        if err == nil </span><span class="cov0" title="0">{
                image.Uploader = &amp;uploader
        }</span>
        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "errors"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

type SMSRepository struct{}

func NewSMSRepository() *SMSRepository <span class="cov0" title="0">{
        return &amp;SMSRepository{}
}</span>

func (r *SMSRepository) Create(code *models.SMSCode) error <span class="cov0" title="0">{
        query := `
                INSERT INTO sms_codes (id, phone, code, used, expires_at, created_at)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id
        `
        code.ID = uuid.New()
        code.CreatedAt = time.Now()

        row := database.DB.Raw(
                query, code.ID, code.Phone, code.Code, code.Used, code.ExpiresAt, code.CreatedAt,
        ).Row()
        return row.Scan(&amp;code.ID)
}</span>

func (r *SMSRepository) GetValidCode(phone, code string) (*models.SMSCode, error) <span class="cov0" title="0">{
        smsCode := &amp;models.SMSCode{}
        query := `
                SELECT id, phone, code, used, expires_at, created_at
                FROM sms_codes
                WHERE phone = $1 AND code = $2 AND used = FALSE AND expires_at &gt; $3
                ORDER BY created_at DESC
                LIMIT 1
        `
        now := time.Now()
        result := database.DB.Raw(query, phone, code, now).Scan(smsCode)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid or expired code")
        }</span>
        <span class="cov0" title="0">return smsCode, nil</span>
}

func (r *SMSRepository) MarkAsUsed(id uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE sms_codes SET used = TRUE WHERE id = $1`
        result := database.DB.Exec(query, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("code not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *SMSRepository) GetRecentCodeCount(phone string, since time.Time) (int64, error) <span class="cov0" title="0">{
        var count int64
        query := `
                SELECT COUNT(*)
                FROM sms_codes
                WHERE phone = $1 AND created_at &gt; $2
        `
        err := database.DB.Raw(query, phone, since).Scan(&amp;count).Error
        return count, err
}</span>


</pre>
		
		<pre class="file" id="file24" style="display: none">// Package repository 提供数据访问层的实现
package repository

import (
        "database/sql"
        "errors"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

// TagRepository 标签数据访问层，提供标签相关的数据库操作
type TagRepository struct{}

// NewTagRepository 创建新的标签仓库实例
func NewTagRepository() *TagRepository <span class="cov0" title="0">{
        return &amp;TagRepository{}
}</span>

// Create 创建新标签
// tag: 标签对象，会设置ID、创建时间、更新时间
// 返回: 如果创建失败则返回错误
func (r *TagRepository) Create(tag *models.Tag) error <span class="cov0" title="0">{
        query := `
                INSERT INTO tags (id, name, slug, color, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id
        `
        
        now := time.Now()
        tag.ID = uuid.New()
        tag.CreatedAt = now
        tag.UpdatedAt = now

        row := database.DB.Raw(
                query, tag.ID, tag.Name, tag.Slug, tag.Color, tag.CreatedAt, tag.UpdatedAt,
        ).Row()
        return row.Scan(&amp;tag.ID)
}</span>

// GetByID 根据ID获取标签
// id: 标签UUID
// 返回: 标签对象，如果不存在则返回错误
func (r *TagRepository) GetByID(id uuid.UUID) (*models.Tag, error) <span class="cov0" title="0">{
        tag := &amp;models.Tag{}
        query := `SELECT id, name, slug, color, created_at, updated_at FROM tags WHERE id = $1`
        
        err := database.DB.Raw(query, id).Scan(tag).Error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.New("tag not found")
        }</span>
        <span class="cov0" title="0">return tag, err</span>
}

// GetBySlug 根据slug获取标签
// slug: 标签URL友好的标识符
// 返回: 标签对象，如果不存在则返回错误
func (r *TagRepository) GetBySlug(slug string) (*models.Tag, error) <span class="cov0" title="0">{
        tag := &amp;models.Tag{}
        query := `SELECT id, name, slug, color, created_at, updated_at FROM tags WHERE slug = $1`
        
        err := database.DB.Raw(query, slug).Scan(tag).Error
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, errors.New("tag not found")
        }</span>
        <span class="cov0" title="0">return tag, err</span>
}

// Update 更新标签信息
// tag: 标签对象，会更新更新时间
// 返回: 如果更新失败或标签不存在则返回错误
func (r *TagRepository) Update(tag *models.Tag) error <span class="cov0" title="0">{
        query := `
                UPDATE tags 
                SET name = $2, slug = $3, color = $4, updated_at = $5
                WHERE id = $1
        `
        
        tag.UpdatedAt = time.Now()
        result := database.DB.Exec(query, tag.ID, tag.Name, tag.Slug, tag.Color, tag.UpdatedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("tag not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete 删除标签（硬删除）
// id: 标签UUID
// 返回: 如果删除失败或标签不存在则返回错误
func (r *TagRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        query := `DELETE FROM tags WHERE id = $1`
        result := database.DB.Exec(query, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("tag not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *TagRepository) List() ([]*models.Tag, error) <span class="cov0" title="0">{
        var tags []*models.Tag
        query := `SELECT id, name, slug, color, created_at, updated_at FROM tags ORDER BY name ASC`
        
        err := database.DB.Raw(query).Scan(&amp;tags).Error
        return tags, err
}</span>

</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "errors"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"

        "github.com/google/uuid"
)

type UserRepository struct{}

func NewUserRepository() *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{}
}</span>

func (r *UserRepository) Create(user *models.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (id, username, email, phone, password, role, avatar, bio, status, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                RETURNING id
        `
        
        now := time.Now()
        user.ID = uuid.New()
        user.CreatedAt = now
        user.UpdatedAt = now
        
        if user.Status == "" </span><span class="cov0" title="0">{
                user.Status = "active"
        }</span>
        <span class="cov0" title="0">if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = models.RoleReader
        }</span>

        <span class="cov0" title="0">row := database.DB.Raw(
                query,
                user.ID, user.Username, user.Email, user.Phone, user.Password, user.Role,
                user.Avatar, user.Bio, user.Status, user.CreatedAt, user.UpdatedAt,
        ).Row()
        return row.Scan(&amp;user.ID)</span>
}

func (r *UserRepository) GetByID(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `SELECT id, username, email, phone, password, role, avatar, bio, status, created_at, updated_at, deleted_at
                          FROM users WHERE id = $1 AND deleted_at IS NULL`
        
        result := database.DB.Raw(query, id).Scan(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByPhone(phone string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `SELECT id, username, email, phone, password, role, avatar, bio, status, created_at, updated_at, deleted_at
                          FROM users WHERE phone = $1 AND deleted_at IS NULL`
        
        result := database.DB.Raw(query, phone).Scan(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `SELECT id, username, email, phone, password, role, avatar, bio, status, created_at, updated_at, deleted_at
                          FROM users WHERE email = $1 AND deleted_at IS NULL`
        
        result := database.DB.Raw(query, email).Scan(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetByUsername(username string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `SELECT id, username, email, phone, password, role, avatar, bio, status, created_at, updated_at, deleted_at
                          FROM users WHERE username = $1 AND deleted_at IS NULL`
        
        result := database.DB.Raw(query, username).Scan(user)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET username = $2, email = $3, phone = $4, role = $5, avatar = $6, bio = $7, status = $8, updated_at = $9
                WHERE id = $1 AND deleted_at IS NULL
        `
        
        user.UpdatedAt = time.Now()
        result := database.DB.Exec(query, user.ID, user.Username, user.Email, user.Phone, user.Role,
                user.Avatar, user.Bio, user.Status, user.UpdatedAt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UpdatePassword 仅更新用户密码（已在 service 层完成哈希）
func (r *UserRepository) UpdatePassword(id uuid.UUID, hashedPassword string) error <span class="cov0" title="0">{
        query := `
                UPDATE users
                SET password = $2, updated_at = $3
                WHERE id = $1 AND deleted_at IS NULL
        `
        now := time.Now()
        result := database.DB.Exec(query, id, hashedPassword, now)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepository) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        query := `UPDATE users SET deleted_at = $1 WHERE id = $2 AND deleted_at IS NULL`
        result := database.DB.Exec(query, time.Now(), id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepository) List(page, pageSize int) ([]*models.User, int64, error) <span class="cov0" title="0">{
        var users []*models.User
        var total int64

        offset := (page - 1) * pageSize

        // 获取总数
        countQuery := `SELECT COUNT(*) FROM users WHERE deleted_at IS NULL`
        err := database.DB.Raw(countQuery).Scan(&amp;total).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 获取列表
        <span class="cov0" title="0">query := `SELECT id, username, email, role, avatar, bio, status, created_at, updated_at
                          FROM users WHERE deleted_at IS NULL
                          ORDER BY created_at DESC LIMIT $1 OFFSET $2`
        
        err = database.DB.Raw(query, pageSize, offset).Scan(&amp;users).Error
        return users, total, err</span>
}

</pre>
		
		<pre class="file" id="file26" style="display: none">// Package search 提供全文搜索功能，基于 Elasticsearch 实现
//
// 设计思路：
// 1. 使用 Elasticsearch 作为全文搜索引擎，提供高性能的搜索能力
// 2. 支持多种搜索策略：精确匹配、前缀匹配、模糊匹配、通配符匹配
// 3. 支持多字段搜索，不同字段设置不同权重（title &gt; excerpt &gt; content）
// 4. 支持筛选和排序功能
// 5. 优雅降级：如果 Elasticsearch 未启用或连接失败，不影响系统正常运行
package search

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "enterprise-blog/internal/config"
        "enterprise-blog/internal/models"
        "enterprise-blog/pkg/logger"

        "github.com/elastic/go-elasticsearch/v8"
        "github.com/google/uuid"
)

// esClient Elasticsearch 客户端实例（全局变量，单例模式）
// 在 InitElasticsearch 中初始化，如果初始化失败则为 nil
var esClient *elasticsearch.Client

// articleIndex Elasticsearch 索引名称，用于存储文章数据
const articleIndex = "articles"

// InitElasticsearch 初始化 Elasticsearch 客户端
//
// 功能说明：
// - 从配置文件读取 Elasticsearch 配置（URL、是否启用）
// - 创建 Elasticsearch 客户端连接
// - 执行健康检查（ping），确保连接可用
// - 如果初始化失败，仅记录警告日志，不影响系统启动
//
// 设计考虑：
// - 使用优雅降级策略：Elasticsearch 不可用时，系统仍可正常运行
// - 使用超时控制（2秒），避免启动时长时间阻塞
// - 单例模式：全局只有一个客户端实例，节省资源
//
// 面试要点：
// - 为什么使用单例模式？避免重复创建连接，节省资源
// - 为什么使用优雅降级？提高系统可用性，即使搜索服务不可用，其他功能仍可用
func InitElasticsearch() <span class="cov0" title="0">{
        if !config.AppConfig.Elasticsearch.Enabled </span><span class="cov0" title="0">{
                // Elasticsearch 未启用
                return
        }</span>

        <span class="cov0" title="0">url := config.AppConfig.Elasticsearch.URL
        if url == "" </span><span class="cov0" title="0">{
                // 未配置URL则不启用
                l := logger.GetLogger()
                l.Warn().Msg("Elasticsearch enabled but URL not configured, search disabled")
                return
        }</span>

        <span class="cov0" title="0">cfg := elasticsearch.Config{
                Addresses: []string{url},
        }
        client, err := elasticsearch.NewClient(cfg)
        if err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Warn().Err(err).Msg("failed to init elasticsearch client, search disabled")
                return
        }</span>

        // 简单 ping 校验
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        if _, err := client.Info(client.Info.WithContext(ctx)); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Warn().Err(err).Msg("failed to connect to elasticsearch, search disabled")
                return
        }</span>

        <span class="cov0" title="0">esClient = client
        l := logger.GetLogger()
        l.Info().Str("url", url).Msg("Elasticsearch client initialized")</span>
}

// IndexArticle 在 Elasticsearch 中索引一篇文章（用于创建/更新）
//
// 参数说明：
// - ctx: 上下文，用于控制请求超时和取消
// - article: 要索引的文章对象
//
// 返回值：
// - error: 如果索引失败则返回错误，否则返回 nil
//
// 功能说明：
// - 将文章数据转换为 Elasticsearch 文档格式
// - 使用文章 ID 作为文档 ID，确保同一篇文章的更新会覆盖旧文档
// - 设置 refresh="false"，不立即刷新索引，提高性能（最终一致性）
//
// 数据结构：
// - title: 文章标题（用于搜索）
// - content: 文章内容（用于搜索）
// - excerpt: 文章摘要（用于搜索）
// - status: 文章状态（用于筛选）
// - author_id: 作者ID（用于筛选）
// - category_id: 分类ID（用于筛选，可为空）
// - published_at: 发布时间（用于排序）
// - created_at: 创建时间（用于排序）
//
// 设计考虑：
// - 使用 UUID 作为文档 ID，确保全局唯一性
// - 异步索引：通常在 Service 层异步调用，不阻塞主流程
// - 错误处理：索引失败不影响数据库操作，仅记录日志
//
// 面试要点：
// - 为什么使用 refresh="false"？提高写入性能，但会有短暂延迟（最终一致性）
// - 如何处理索引失败？记录日志，不影响主流程，可以后续重试
func IndexArticle(ctx context.Context, article *models.Article) error <span class="cov0" title="0">{
        if esClient == nil || article == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">doc := map[string]interface{}{
                "title":        article.Title,
                "content":      article.Content,
                "excerpt":      article.Excerpt,
                "status":       string(article.Status),
                "author_id":    article.AuthorID.String(),
                "category_id":  nil,
                "published_at": article.PublishedAt,
                "created_at":   article.CreatedAt,
        }
        if article.CategoryID != nil </span><span class="cov0" title="0">{
                doc["category_id"] = article.CategoryID.String()
        }</span>

        <span class="cov0" title="0">body, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req := esClient.Index.WithContext(ctx)
        res, err := esClient.Index(
                articleIndex,
                bytes.NewReader(body),
                req,
                esClient.Index.WithDocumentID(article.ID.String()),
                esClient.Index.WithRefresh("false"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        if res.IsError() </span><span class="cov0" title="0">{
                return fmt.Errorf("elasticsearch index error: %s", res.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteArticle 从 Elasticsearch 中删除文章文档
//
// 参数说明：
// - ctx: 上下文，用于控制请求超时和取消
// - id: 要删除的文章 UUID
//
// 返回值：
// - error: 如果删除失败则返回错误，否则返回 nil
//
// 功能说明：
// - 根据文章 ID 删除 Elasticsearch 中的文档
// - 如果文档不存在，不视为错误（幂等性）
// - 设置 refresh="false"，不立即刷新索引
//
// 设计考虑：
// - 幂等性：多次删除同一文档不会报错
// - 软删除：如果数据库使用软删除，这里也应该同步删除，避免搜索结果中出现已删除文章
//
// 面试要点：
// - 为什么删除不存在的文档不报错？保证幂等性，简化错误处理
func DeleteArticle(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        if esClient == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">res, err := esClient.Delete(
                articleIndex,
                id.String(),
                esClient.Delete.WithContext(ctx),
                esClient.Delete.WithRefresh("false"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        // 删除不存在的文档不视为错误
        return nil</span>
}

// SearchArticles 使用 Elasticsearch 搜索文章，返回文章 ID 列表和总数
//
// 参数说明：
// - ctx: 上下文，用于控制请求超时和取消
// - query: 文章查询条件，包含：
//   - Search: 搜索关键词（可选）
//   - Status: 文章状态筛选（可选）
//   - CategoryID: 分类ID筛选（可选）
//   - AuthorID: 作者ID筛选（可选）
//   - Page: 页码（默认1）
//   - PageSize: 每页数量（默认10，最大50）
//   - SortBy: 排序字段（可选）
//   - Order: 排序方向（asc/desc，可选）
//
// 返回值：
// - []uuid.UUID: 匹配的文章ID列表（按排序顺序）
// - int64: 匹配的文章总数（用于分页）
// - error: 如果搜索失败则返回错误
//
// 搜索策略（多策略组合，提高搜索准确性和召回率）：
// 1. 精确匹配（multi_match, best_fields）：在标题、摘要、内容中精确匹配，权重最高
//   - title 权重 5，excerpt 权重 3，content 权重 1
//
// 2. 前缀匹配（multi_match, phrase_prefix）：支持部分词匹配，如输入"Go"可以匹配"Golang"
// 3. 模糊匹配（match, fuzziness: AUTO）：支持拼写错误，如"golang"可以匹配"golang"
// 4. 通配符匹配（query_string）：支持通配符，如"*go*"可以匹配包含"go"的所有词
//
// 设计考虑：
// - 使用 bool 查询的 should 子句，至少匹配一个条件即可
// - 不同匹配策略有不同的权重，精确匹配优先级最高
// - 转义特殊字符，防止查询注入攻击
// - 支持筛选条件（status、category、author），使用 filter 子句（不计算相关性分数，性能更好）
// - 默认按创建时间倒序排序，最新的在前
// - 分页参数验证和限制，防止恶意请求
//
// 性能优化：
// - filter 子句不计算相关性分数，比 must 子句性能更好
// - 使用白名单验证排序字段，防止注入攻击
// - 限制每页最大数量（50），防止单次查询返回过多数据
//
// 错误处理：
// - 解析 Elasticsearch 错误响应，提取详细的错误信息
// - 支持 root_cause 错误信息，便于调试
//
// 面试要点：
// - 为什么使用多种搜索策略？提高搜索的准确性和召回率，满足不同用户需求
// - 为什么使用 filter 而不是 must？filter 不计算相关性分数，性能更好，适合精确匹配
// - 如何处理特殊字符？转义特殊字符，防止查询注入和查询错误
// - 如何保证搜索性能？使用 filter、限制分页大小、合理使用索引
func SearchArticles(ctx context.Context, query models.ArticleQuery) ([]uuid.UUID, int64, error) <span class="cov0" title="0">{
        if esClient == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("elasticsearch not initialized")
        }</span>
        <span class="cov0" title="0">if query.Page &lt;= 0 </span><span class="cov0" title="0">{
                query.Page = 1
        }</span>
        <span class="cov0" title="0">if query.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                query.PageSize = 10
        }</span>
        <span class="cov0" title="0">if query.PageSize &gt; 50 </span><span class="cov0" title="0">{
                query.PageSize = 50
        }</span>

        <span class="cov0" title="0">from := (query.Page - 1) * query.PageSize

        // 构建查询条件
        var esQuery map[string]interface{}

        if query.Search != "" </span><span class="cov0" title="0">{
                // 转义搜索关键词中的特殊字符，防止查询注入和查询错误
                // Elasticsearch 的 query_string 查询支持特殊字符，需要转义以避免被解释为操作符
                // 转义的字符包括：* ? + - &amp;&amp; || ! ( ) { } [ ] ^ " ~ :
                escapedSearch := strings.ReplaceAll(query.Search, "*", "\\*")
                escapedSearch = strings.ReplaceAll(escapedSearch, "?", "\\?")
                escapedSearch = strings.ReplaceAll(escapedSearch, "+", "\\+")
                escapedSearch = strings.ReplaceAll(escapedSearch, "-", "\\-")
                escapedSearch = strings.ReplaceAll(escapedSearch, "&amp;&amp;", "\\&amp;&amp;")
                escapedSearch = strings.ReplaceAll(escapedSearch, "||", "\\||")
                escapedSearch = strings.ReplaceAll(escapedSearch, "!", "\\!")
                escapedSearch = strings.ReplaceAll(escapedSearch, "(", "\\(")
                escapedSearch = strings.ReplaceAll(escapedSearch, ")", "\\)")
                escapedSearch = strings.ReplaceAll(escapedSearch, "{", "\\{")
                escapedSearch = strings.ReplaceAll(escapedSearch, "}", "\\}")
                escapedSearch = strings.ReplaceAll(escapedSearch, "[", "\\[")
                escapedSearch = strings.ReplaceAll(escapedSearch, "]", "\\]")
                escapedSearch = strings.ReplaceAll(escapedSearch, "^", "\\^")
                escapedSearch = strings.ReplaceAll(escapedSearch, "\"", "\\\"")
                escapedSearch = strings.ReplaceAll(escapedSearch, "~", "\\~")
                escapedSearch = strings.ReplaceAll(escapedSearch, ":", "\\:")

                // 使用 bool 查询组合多种搜索策略，提高搜索准确性和召回率
                // should 子句：至少匹配一个条件即可（minimum_should_match: 1）
                // 不同策略有不同的权重和优先级，精确匹配权重最高
                shouldClauses := []map[string]interface{}{
                        // 策略1：精确匹配（高优先级）
                        // multi_match 的 best_fields 类型：在多个字段中查找，返回最佳匹配字段的分数
                        // 字段权重：title^5 表示标题权重是内容的5倍，excerpt^3 表示摘要权重是内容的3倍
                        // 这样标题匹配的文章会排在前面
                        {
                                "multi_match": map[string]interface{}{
                                        "query":  query.Search,
                                        "fields": []string{"title^5", "excerpt^3", "content"},
                                        "type":   "best_fields",
                                },
                        },
                        // 策略2：前缀匹配（支持部分匹配）
                        // phrase_prefix 类型：支持短语前缀匹配，如输入"Go"可以匹配"Golang"
                        // 适用于用户输入不完整的情况
                        {
                                "multi_match": map[string]interface{}{
                                        "query":  query.Search,
                                        "fields": []string{"title^3", "excerpt^2", "content"},
                                        "type":   "phrase_prefix",
                                },
                        },
                        // 策略3：模糊匹配（支持拼写错误）
                        // fuzziness: "AUTO" 表示自动计算编辑距离，支持拼写错误纠正
                        // 如"golang"可以匹配"golang"（即使有拼写错误）
                        // boost: 2.0 表示标题的模糊匹配权重是内容的2倍
                        {
                                "match": map[string]interface{}{
                                        "title": map[string]interface{}{
                                                "query":     query.Search,
                                                "fuzziness": "AUTO",
                                                "boost":     2.0,
                                        },
                                },
                        },
                        {
                                "match": map[string]interface{}{
                                        "content": map[string]interface{}{
                                                "query":     query.Search,
                                                "fuzziness": "AUTO",
                                        },
                                },
                        },
                        // 策略4：通配符匹配（支持部分词匹配）
                        // query_string 查询：支持通配符 * 和 ?，如 "*go*" 可以匹配包含 "go" 的所有词
                        // lenient: true 表示允许查询错误，不会导致整个查询失败（容错性）
                        // default_operator: "OR" 表示多个词之间是或的关系
                        {
                                "query_string": map[string]interface{}{
                                        "query":            fmt.Sprintf("*%s*", escapedSearch),
                                        "fields":           []string{"title^2", "excerpt", "content"},
                                        "default_operator": "OR",
                                        "lenient":          true, // 允许查询错误，不会导致整个查询失败
                                },
                        },
                }

                // 构建 bool 查询
                // bool 查询是 Elasticsearch 最强大的查询类型，支持组合多个查询条件
                // should: 应该匹配的条件（至少匹配 minimum_should_match 个）
                // filter: 必须匹配的条件（不计算相关性分数，性能更好）
                boolQuery := map[string]interface{}{
                        "should":               shouldClauses,
                        "minimum_should_match": 1, // 至少匹配一个 should 条件即可
                }

                // 添加筛选条件（使用 filter 子句，不计算相关性分数，性能更好）
                // filter 子句用于精确匹配，如状态、分类、作者等
                filterClauses := []map[string]interface{}{}

                // 状态筛选
                if query.Status != "" </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"status": string(query.Status)},
                        })
                }</span>

                // 分类筛选
                <span class="cov0" title="0">if query.CategoryID != nil </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"category_id": query.CategoryID.String()},
                        })
                }</span>

                // 作者筛选
                <span class="cov0" title="0">if query.AuthorID != nil </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"author_id": query.AuthorID.String()},
                        })
                }</span>

                // 如果有筛选条件，添加到 bool 查询中
                <span class="cov0" title="0">if len(filterClauses) &gt; 0 </span><span class="cov0" title="0">{
                        boolQuery["filter"] = filterClauses
                }</span>

                <span class="cov0" title="0">esQuery = map[string]interface{}{
                        "bool": boolQuery,
                }</span>
        } else<span class="cov0" title="0"> {
                // 如果没有搜索关键词，只使用筛选条件
                filterClauses := []map[string]interface{}{}

                if query.Status != "" </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"status": string(query.Status)},
                        })
                }</span>
                <span class="cov0" title="0">if query.CategoryID != nil </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"category_id": query.CategoryID.String()},
                        })
                }</span>
                <span class="cov0" title="0">if query.AuthorID != nil </span><span class="cov0" title="0">{
                        filterClauses = append(filterClauses, map[string]interface{}{
                                "term": map[string]interface{}{"author_id": query.AuthorID.String()},
                        })
                }</span>

                <span class="cov0" title="0">if len(filterClauses) &gt; 0 </span><span class="cov0" title="0">{
                        esQuery = map[string]interface{}{
                                "bool": map[string]interface{}{
                                        "filter": filterClauses,
                                },
                        }
                }</span> else<span class="cov0" title="0"> {
                        // 如果没有筛选条件，匹配所有文档
                        esQuery = map[string]interface{}{
                                "match_all": map[string]interface{}{},
                        }
                }</span>
        }

        // 构建排序：默认按创建时间倒序（最新的在前）
        // 这是最常见的排序需求，用户通常想看最新的文章
        <span class="cov0" title="0">sort := []map[string]interface{}{
                {
                        "created_at": map[string]interface{}{
                                "order": "desc",
                        },
                },
        }

        // 如果指定了其他排序字段，优先使用指定的排序
        // 支持自定义排序字段和排序方向，提高灵活性
        if query.SortBy != "" </span><span class="cov0" title="0">{
                order := "desc" // 默认倒序
                if query.Order != "" </span><span class="cov0" title="0">{
                        order = strings.ToLower(query.Order)
                }</span>
                // 验证排序字段（白名单验证，防止注入攻击）
                // 只允许排序指定的字段，防止用户通过排序字段进行注入攻击
                <span class="cov0" title="0">allowedSortFields := map[string]string{
                        "created_at":   "created_at",
                        "updated_at":   "updated_at",
                        "published_at": "published_at",
                }
                if sortField, ok := allowedSortFields[query.SortBy]; ok </span><span class="cov0" title="0">{
                        sort = []map[string]interface{}{
                                {
                                        sortField: map[string]interface{}{
                                                "order": order,
                                        },
                                },
                        }
                }</span>
        }

        <span class="cov0" title="0">body := map[string]interface{}{
                "from":  from,
                "size":  query.PageSize,
                "query": esQuery,
                "sort":  sort,
        }

        reqBody, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">res, err := esClient.Search(
                esClient.Search.WithContext(ctx),
                esClient.Search.WithIndex(articleIndex),
                esClient.Search.WithBody(bytes.NewReader(reqBody)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("elasticsearch request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        if res.IsError() </span><span class="cov0" title="0">{
                // 读取错误响应体，提取详细的错误信息
                // Elasticsearch 的错误响应格式：
                // {
                //   "error": {
                //     "type": "query_shard_exception",
                //     "reason": "详细错误原因",
                //     "root_cause": [{"reason": "根本原因"}]
                //   }
                // }
                var errBody map[string]interface{}
                if decodeErr := json.NewDecoder(res.Body).Decode(&amp;errBody); decodeErr == nil </span><span class="cov0" title="0">{
                        if errorInfo, ok := errBody["error"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                // 优先使用 reason 字段的错误信息
                                if reason, ok := errorInfo["reason"].(string); ok </span><span class="cov0" title="0">{
                                        return nil, 0, fmt.Errorf("elasticsearch search error: %s", reason)
                                }</span>
                                // 如果没有 reason，尝试从 root_cause 获取
                                <span class="cov0" title="0">if rootCause, ok := errorInfo["root_cause"].([]interface{}); ok &amp;&amp; len(rootCause) &gt; 0 </span><span class="cov0" title="0">{
                                        if firstCause, ok := rootCause[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if reason, ok := firstCause["reason"].(string); ok </span><span class="cov0" title="0">{
                                                        return nil, 0, fmt.Errorf("elasticsearch search error: %s", reason)
                                                }</span>
                                        }
                                }
                        }
                }
                // 如果无法解析错误响应，返回原始错误信息（包含查询内容，便于调试）
                <span class="cov0" title="0">bodyBytes, _ := json.Marshal(reqBody)
                return nil, 0, fmt.Errorf("elasticsearch search error (status: %d): query=%s", res.StatusCode, string(bodyBytes))</span>
        }

        // 解析搜索结果
        // Elasticsearch 的搜索结果格式：
        // {
        //   "hits": {
        //     "total": {"value": 100},  // 匹配的总数
        //     "hits": [                 // 匹配的文档列表
        //       {"_id": "uuid1"},
        //       {"_id": "uuid2"}
        //     ]
        //   }
        // }
        <span class="cov0" title="0">var result struct {
                Hits struct {
                        Total struct {
                                Value int64 `json:"value"` // 匹配的总数（用于分页）
                        } `json:"total"`
                        Hits []struct {
                                ID string `json:"_id"` // 文档ID（即文章UUID）
                        } `json:"hits"`
                } `json:"hits"`
        }
        if err := json.NewDecoder(res.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 将文档ID转换为UUID列表
        // 只返回ID，不返回完整文档，减少网络传输和内存占用
        // 后续可以根据ID从数据库查询完整文章信息
        <span class="cov0" title="0">var ids []uuid.UUID
        for _, h := range result.Hits.Hits </span><span class="cov0" title="0">{
                if id, err := uuid.Parse(h.ID); err == nil </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                // 如果ID解析失败，跳过该结果（记录日志但不中断流程）
        }

        <span class="cov0" title="0">return ids, result.Hits.Total.Value, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"
        "enterprise-blog/internal/search"
        "enterprise-blog/pkg/logger"

        "github.com/google/uuid"
        "github.com/redis/go-redis/v9"
)

// ArticleService 文章服务，提供文章相关的业务逻辑
type ArticleService struct {
        articleRepo  *repository.ArticleRepository
        categoryRepo *repository.CategoryRepository
        tagRepo      *repository.TagRepository
}

// NewArticleService 创建新的文章服务实例
// articleRepo: 文章数据访问层仓库
// categoryRepo: 分类数据访问层仓库
// tagRepo: 标签数据访问层仓库
func NewArticleService(
        articleRepo *repository.ArticleRepository,
        categoryRepo *repository.CategoryRepository,
        tagRepo *repository.TagRepository,
) *ArticleService <span class="cov0" title="0">{
        return &amp;ArticleService{
                articleRepo:  articleRepo,
                categoryRepo: categoryRepo,
                tagRepo:      tagRepo,
        }
}</span>

// Create 创建新文章
// authorID: 作者用户UUID
// req: 文章创建请求，包含标题、内容、分类、标签等
// 返回: 创建成功的文章对象（包含关联的作者、分类、标签），如果创建失败则返回错误
// 注意: 会自动生成slug（如果冲突会自动添加数字后缀），自动生成摘要，支持标签关联
func (s *ArticleService) Create(authorID uuid.UUID, req *models.ArticleCreate) (*models.Article, error) <span class="cov0" title="0">{
        // 生成slug
        slug := GenerateSlug(req.Title)
        if slug == "" </span><span class="cov0" title="0">{
                slug = "article"
        }</span>
        // 检查slug是否已存在，如果存在则添加数字后缀
        <span class="cov0" title="0">originalSlug := slug
        counter := 1

        // 生成摘要
        excerpt := req.Excerpt
        if excerpt == "" &amp;&amp; len(req.Content) &gt; 200 </span><span class="cov0" title="0">{
                excerpt = req.Content[:200] + "..."
        }</span> else<span class="cov0" title="0"> if excerpt == "" </span><span class="cov0" title="0">{
                excerpt = req.Content
        }</span>

        <span class="cov0" title="0">article := &amp;models.Article{
                Title:      req.Title,
                Slug:       slug,
                Content:    req.Content,
                Excerpt:    excerpt,
                CoverImage: req.CoverImage,
                Status:     req.Status,
                AuthorID:   authorID,
        }

        if article.Status == "" </span><span class="cov0" title="0">{
                article.Status = models.StatusDraft
        }</span>

        <span class="cov0" title="0">if req.CategoryID != nil </span><span class="cov0" title="0">{
                article.CategoryID = req.CategoryID
        }</span>

        // 创建时如果遇到 slug 唯一约束冲突，则自动追加数字后缀重试几次
        <span class="cov0" title="0">const maxSlugRetries = 5
        for retries := 0; retries &lt; maxSlugRetries; retries++ </span><span class="cov0" title="0">{
                article.Slug = slug

                if err := s.articleRepo.Create(context.Background(), article); err != nil </span><span class="cov0" title="0">{
                        // 唯一约束冲突：尝试下一个 slug
                        if isSlugUniqueViolation(err) </span><span class="cov0" title="0">{
                                slug = fmt.Sprintf("%s-%d", originalSlug, counter)
                                counter++
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to create article: %w", err)</span>
                }

                // 如果需要标签，追加标签关系
                <span class="cov0" title="0">if len(req.TagIDs) &gt; 0 </span><span class="cov0" title="0">{
                        if err := s.articleRepo.AddTags(article.ID, req.TagIDs); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to add article tags: %w", err)
                        }</span>
                }

                // 创建成功，重新从数据库获取完整数据（含作者、分类、标签等关联）
                <span class="cov0" title="0">created, err := s.articleRepo.GetByIDWithContext(context.Background(), article.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 写入详情缓存，并清理列表缓存
                <span class="cov0" title="0">_ = cacheArticleDetail(created)
                clearArticleListCache()

                // 异步同步到 Elasticsearch（如果已启用）
                go func(a *models.Article) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                        defer cancel()
                        _ = search.IndexArticle(ctx, a)
                }</span>(created)

                <span class="cov0" title="0">return created, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to create article: slug already exists after %d retries", maxSlugRetries)</span>
}

// GetByID 根据ID获取文章详情
// id: 文章UUID
// 返回: 文章对象（包含关联的作者、分类、标签），如果不存在则返回错误
// 注意: 优先从Redis缓存读取，缓存未命中时从数据库读取并写入缓存，会异步增加浏览计数
func (s *ArticleService) GetByID(id uuid.UUID) (*models.Article, error) <span class="cov0" title="0">{
        // 优先从缓存读取
        if article, err := getArticleDetailFromCache(id); err == nil &amp;&amp; article != nil </span><span class="cov0" title="0">{
                // 增加浏览计数（缓冲）
                go incrementArticleViewCountBuffered(article.ID)
                return article, nil
        }</span>

        <span class="cov0" title="0">article, err := s.articleRepo.GetByIDWithContext(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 写入缓存（忽略错误）
        <span class="cov0" title="0">_ = cacheArticleDetail(article)

        // 增加浏览计数：优先写入 Redis 作为缓冲，失败时退回到数据库自增
        go incrementArticleViewCountBuffered(article.ID)

        return article, nil</span>
}

// GetBySlug 根据slug获取文章详情
// slug: 文章URL友好的标识符
// 返回: 文章对象，如果不存在则返回错误
// 注意: 会异步增加浏览计数
func (s *ArticleService) GetBySlug(slug string) (*models.Article, error) <span class="cov0" title="0">{
        article, err := s.articleRepo.GetBySlugWithContext(context.Background(), slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 增加浏览次数
        <span class="cov0" title="0">go s.articleRepo.IncrementViewCount(article.ID)

        return article, nil</span>
}

// Update 更新文章信息
// id: 文章UUID
// req: 文章更新请求，包含可选的标题、内容、摘要、封面、状态、分类、标签等
// 返回: 更新后的文章对象，如果更新失败则返回错误
// 注意: 标题改变时会自动更新slug，内容改变时会自动生成摘要，会清理相关缓存并异步同步到Elasticsearch
func (s *ArticleService) Update(id uuid.UUID, req *models.ArticleUpdate) (*models.Article, error) <span class="cov0" title="0">{
        article, err := s.articleRepo.GetByIDWithContext(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Title != nil </span><span class="cov0" title="0">{
                article.Title = *req.Title
                // 如果标题改变，更新slug
                article.Slug = GenerateSlug(*req.Title)
        }</span>

        <span class="cov0" title="0">if req.Content != nil </span><span class="cov0" title="0">{
                article.Content = *req.Content
                // 如果内容改变但没有摘要，自动生成摘要
                if req.Excerpt == nil </span><span class="cov0" title="0">{
                        if len(*req.Content) &gt; 200 </span><span class="cov0" title="0">{
                                article.Excerpt = (*req.Content)[:200] + "..."
                        }</span> else<span class="cov0" title="0"> {
                                article.Excerpt = *req.Content
                        }</span>
                }
        }

        <span class="cov0" title="0">if req.Excerpt != nil </span><span class="cov0" title="0">{
                article.Excerpt = *req.Excerpt
        }</span>

        <span class="cov0" title="0">if req.CoverImage != nil </span><span class="cov0" title="0">{
                article.CoverImage = *req.CoverImage
        }</span>

        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                article.Status = *req.Status
        }</span>
        <span class="cov0" title="0">if req.CategoryID != nil </span><span class="cov0" title="0">{
                article.CategoryID = req.CategoryID
        }</span>

        <span class="cov0" title="0">if err := s.articleRepo.Update(article); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 如传入标签 ID，则替换标签关系
        <span class="cov0" title="0">if len(req.TagIDs) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.articleRepo.ReplaceTags(article.ID, req.TagIDs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">updated, err := s.articleRepo.GetByIDWithContext(context.Background(), id)
        if err == nil </span><span class="cov0" title="0">{
                // 更新详情缓存，并清理列表缓存
                _ = cacheArticleDetail(updated)
                clearArticleListCache()

                // 异步同步到 Elasticsearch
                go func(a *models.Article) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                        defer cancel()
                        _ = search.IndexArticle(ctx, a)
                }</span>(updated)
        }

        <span class="cov0" title="0">return updated, err</span>
}

// Delete 删除文章（软删除）
// id: 文章UUID
// 返回: 如果删除失败则返回错误
// 注意: 会清理相关缓存并异步从Elasticsearch删除文档
func (s *ArticleService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        if err := s.articleRepo.Delete(id); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // 删除详情缓存并清理列表缓存
        <span class="cov0" title="0">deleteArticleDetailCache(id)
        clearArticleListCache()

        // 异步从 Elasticsearch 删除文档
        go func(articleID uuid.UUID) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                defer cancel()
                _ = search.DeleteArticle(ctx, articleID)
        }</span>(id)

        <span class="cov0" title="0">return nil</span>
}

// List 获取文章列表（分页、筛选、搜索、排序）
// query: 文章查询条件，包含页码、每页数量、状态、分类、标签、作者、搜索关键词、排序等
// 返回: 文章列表、总数，如果查询失败则返回错误
// 注意: 
//   - 如果有搜索关键词，使用Elasticsearch进行全文搜索
//   - 如果没有搜索关键词，从数据库查询
//   - 优先从Redis缓存读取，缓存未命中时从数据库/Elasticsearch读取并写入缓存
func (s *ArticleService) List(query models.ArticleQuery) ([]*models.Article, int64, error) <span class="cov0" title="0">{
        if query.Page &lt;= 0 </span><span class="cov0" title="0">{
                query.Page = 1
        }</span>
        <span class="cov0" title="0">if query.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                query.PageSize = 10
        }</span>
        <span class="cov0" title="0">if query.PageSize &gt; 100 </span><span class="cov0" title="0">{
                query.PageSize = 100
        }</span>

        // 如果有搜索关键词，使用Elasticsearch进行全文搜索
        <span class="cov0" title="0">if query.Search != "" </span><span class="cov0" title="0">{
                return s.searchWithElasticsearch(query)
        }</span>

        // 尝试从缓存读取列表
        <span class="cov0" title="0">if articles, total, err := getArticleListFromCache(query); err == nil &amp;&amp; articles != nil </span><span class="cov0" title="0">{
                return articles, total, nil
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        articles, total, err := s.articleRepo.List(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 写入缓存（忽略错误）
        <span class="cov0" title="0">_ = cacheArticleList(query, articles, total)

        return articles, total, nil</span>
}

// searchWithElasticsearch 使用Elasticsearch进行全文搜索
// query: 文章查询条件，必须包含Search字段
// 返回: 文章列表、总数，如果搜索失败则返回错误
// 注意: 如果Elasticsearch不可用，返回错误（不再fallback到PostgreSQL）
func (s *ArticleService) searchWithElasticsearch(query models.ArticleQuery) ([]*models.Article, int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // 使用Elasticsearch搜索（支持模糊搜索和按创建时间排序）
        ids, total, err := search.SearchArticles(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Error().Err(err).Msg("Elasticsearch search failed")
                return nil, 0, fmt.Errorf("search service unavailable: %w", err)
        }</span>

        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return []*models.Article{}, 0, nil
        }</span>

        // 从数据库批量获取文章详情（保持原有逻辑，但可以优化为批量查询）
        <span class="cov0" title="0">articles := make([]*models.Article, 0, len(ids))
        for _, id := range ids </span><span class="cov0" title="0">{
                art, err := s.articleRepo.GetByIDWithContext(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        // 如果文章不存在或已删除，跳过
                        continue</span>
                }
                // 应用其他筛选条件（状态、分类、标签、作者）
                <span class="cov0" title="0">if query.Status != "" &amp;&amp; art.Status != query.Status </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if query.CategoryID != nil &amp;&amp; (art.CategoryID == nil || *art.CategoryID != *query.CategoryID) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if query.AuthorID != nil &amp;&amp; art.AuthorID != *query.AuthorID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if query.TagID != nil </span><span class="cov0" title="0">{
                        hasTag := false
                        for _, tag := range art.Tags </span><span class="cov0" title="0">{
                                if tag.ID == *query.TagID </span><span class="cov0" title="0">{
                                        hasTag = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !hasTag </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">articles = append(articles, art)</span>
        }

        // 更新总数（根据筛选后的结果）
        <span class="cov0" title="0">total = int64(len(articles))

        return articles, total, nil</span>
}

func (s *ArticleService) Like(id uuid.UUID) error <span class="cov0" title="0">{
        // 点赞计数：优先写入 Redis 作为缓冲，失败时退回到数据库自增
        if err := incrementArticleLikeCountBuffered(id); err != nil </span><span class="cov0" title="0">{
                // 记录日志，但不中断请求
                return s.articleRepo.IncrementLikeCount(id)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SearchWithElasticsearch 使用Elasticsearch进行全文搜索（已废弃，使用List方法替代）
// 保留此方法以保持向后兼容，但内部调用List方法
// Deprecated: 使用List方法，传入包含Search字段的ArticleQuery
func (s *ArticleService) SearchWithElasticsearch(query string, page, pageSize int) ([]*models.Article, int64, error) <span class="cov0" title="0">{
        searchQuery := models.ArticleQuery{
                Page:     page,
                PageSize: pageSize,
                Search:   query,
        }
        return s.List(searchQuery)
}</span>

// isSlugUniqueViolation 判断是否为 articles.slug 唯一约束冲突
func isSlugUniqueViolation(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // 目前使用字符串包含判断，兼容 pq/pgx 等驱动的错误文案
        <span class="cov0" title="0">msg := err.Error()
        return strings.Contains(msg, "duplicate key value violates unique constraint") &amp;&amp;
                strings.Contains(msg, "articles_slug_key")</span>
}

const (
        redisArticleViewKeyPrefix = "blog:article:view:"
        redisArticleLikeKeyPrefix = "blog:article:like:"
        redisArticleDetailPrefix  = "blog:article:detail:"
        redisArticleListPrefix    = "blog:article:list:"
)

// incrementArticleViewCountBuffered 将浏览计数写入 Redis，失败时退回到数据库
func incrementArticleViewCountBuffered(id uuid.UUID) <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                _ = (&amp;repository.ArticleRepository{}).IncrementViewCount(id)
                return
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
        defer cancel()
        key := redisArticleViewKeyPrefix + id.String()
        if err := database.RedisClient.Incr(ctx, key).Err(); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Warn().Err(err).Str("key", key).Msg("failed to increment view count in redis, fallback to db")
                _ = (&amp;repository.ArticleRepository{}).IncrementViewCount(id)
        }</span>
}

// incrementArticleLikeCountBuffered 将点赞计数写入 Redis，失败时返回错误由上层回退处理
func incrementArticleLikeCountBuffered(id uuid.UUID) error <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("redis not initialized")
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
        defer cancel()
        key := redisArticleLikeKeyPrefix + id.String()
        if err := database.RedisClient.Incr(ctx, key).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FlushArticleCountersFromRedis 将 Redis 中的浏览 / 点赞增量批量回刷到数据库
func FlushArticleCountersFromRedis(ctx context.Context) error <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">l := logger.GetLogger()
        rdb := database.RedisClient

        // 浏览计数
        if err := flushCounterPrefix(ctx, rdb, redisArticleViewKeyPrefix, func(id uuid.UUID, delta int64) error </span><span class="cov0" title="0">{
                query := `UPDATE articles SET view_count = view_count + $1 WHERE id = $2`
                return database.DB.Exec(query, delta, id).Error
        }</span>); err != nil <span class="cov0" title="0">{
                l.Error().Err(err).Msg("failed to flush view counters from redis")
        }</span>

        // 点赞计数
        <span class="cov0" title="0">if err := flushCounterPrefix(ctx, rdb, redisArticleLikeKeyPrefix, func(id uuid.UUID, delta int64) error </span><span class="cov0" title="0">{
                query := `UPDATE articles SET like_count = like_count + $1 WHERE id = $2`
                return database.DB.Exec(query, delta, id).Error
        }</span>); err != nil <span class="cov0" title="0">{
                l.Error().Err(err).Msg("failed to flush like counters from redis")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// flushCounterPrefix 扫描指定前缀的计数键，读取增量并应用到数据库，然后删除键
func flushCounterPrefix(
        ctx context.Context,
        rdb redisCmdable,
        prefix string,
        apply func(id uuid.UUID, delta int64) error,
) error <span class="cov0" title="0">{
        var cursor uint64
        for </span><span class="cov0" title="0">{
                keys, next, err := rdb.Scan(ctx, cursor, prefix+"*", 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">cursor = next
                for _, key := range keys </span><span class="cov0" title="0">{
                        val, err := rdb.Get(ctx, key).Int64()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if val == 0 </span><span class="cov0" title="0">{
                                _ = rdb.Del(ctx, key).Err()
                                continue</span>
                        }
                        <span class="cov0" title="0">idStr := strings.TrimPrefix(key, prefix)
                        id, err := uuid.Parse(idStr)
                        if err != nil </span><span class="cov0" title="0">{
                                _ = rdb.Del(ctx, key).Err()
                                continue</span>
                        }
                        <span class="cov0" title="0">if err := apply(id, val); err != nil </span><span class="cov0" title="0">{
                                // 若更新失败，保留键以便下次重试
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = rdb.Del(ctx, key).Err()</span>
                }
                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// redisCmdable 抽象 go-redis 客户端用于测试
type redisCmdable interface {
        Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd
        Get(ctx context.Context, key string) *redis.StringCmd
        Del(ctx context.Context, keys ...string) *redis.IntCmd
}

// ---- 文章详情 / 列表缓存 ----

func getArticleDetailFromCache(id uuid.UUID) (*models.Article, error) <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("redis not initialized")
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        key := redisArticleDetailPrefix + id.String()
        val, err := database.RedisClient.Get(ctx, key).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var article models.Article
        if err := json.Unmarshal(val, &amp;article); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;article, nil</span>
}

func cacheArticleDetail(article *models.Article) error <span class="cov0" title="0">{
        if database.RedisClient == nil || article == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        key := redisArticleDetailPrefix + article.ID.String()
        data, err := json.Marshal(article)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return database.RedisClient.Set(ctx, key, data, 60*time.Second).Err()</span>
}

func deleteArticleDetailCache(id uuid.UUID) <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        key := redisArticleDetailPrefix + id.String()
        _ = database.RedisClient.Del(ctx, key).Err()</span>
}

type cachedArticleList struct {
        Articles []*models.Article `json:"articles"`
        Total    int64             `json:"total"`
}

func buildArticleListCacheKey(q models.ArticleQuery) string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(redisArticleListPrefix)
        b.WriteString(fmt.Sprintf("p=%d&amp;ps=%d", q.Page, q.PageSize))
        if q.Status != "" </span><span class="cov0" title="0">{
                b.WriteString("&amp;status=")
                b.WriteString(string(q.Status))
        }</span>
        <span class="cov0" title="0">if q.Search != "" </span><span class="cov0" title="0">{
                b.WriteString("&amp;search=")
                b.WriteString(q.Search)
        }</span>
        <span class="cov0" title="0">if q.SortBy != "" </span><span class="cov0" title="0">{
                b.WriteString("&amp;sort=")
                b.WriteString(q.SortBy)
        }</span>
        <span class="cov0" title="0">if q.Order != "" </span><span class="cov0" title="0">{
                b.WriteString("&amp;order=")
                b.WriteString(q.Order)
        }</span>
        <span class="cov0" title="0">if q.CategoryID != nil </span><span class="cov0" title="0">{
                b.WriteString("&amp;cat=")
                b.WriteString(q.CategoryID.String())
        }</span>
        <span class="cov0" title="0">if q.TagID != nil </span><span class="cov0" title="0">{
                b.WriteString("&amp;tag=")
                b.WriteString(q.TagID.String())
        }</span>
        <span class="cov0" title="0">if q.AuthorID != nil </span><span class="cov0" title="0">{
                b.WriteString("&amp;author=")
                b.WriteString(q.AuthorID.String())
        }</span>
        <span class="cov0" title="0">return b.String()</span>
}

func getArticleListFromCache(q models.ArticleQuery) ([]*models.Article, int64, error) <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("redis not initialized")
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        key := buildArticleListCacheKey(q)
        val, err := database.RedisClient.Get(ctx, key).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">var cached cachedArticleList
        if err := json.Unmarshal(val, &amp;cached); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return cached.Articles, cached.Total, nil</span>
}

func cacheArticleList(q models.ArticleQuery, articles []*models.Article, total int64) error <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()
        key := buildArticleListCacheKey(q)
        data, err := json.Marshal(cachedArticleList{
                Articles: articles,
                Total:    total,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // 列表数据可以稍长一点 TTL
        <span class="cov0" title="0">return database.RedisClient.Set(ctx, key, data, 120*time.Second).Err()</span>
}

// clearArticleListCache 简单粗暴地清理所有文章列表缓存（数据更新后调用）
func clearArticleListCache() <span class="cov0" title="0">{
        if database.RedisClient == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
        defer cancel()
        var cursor uint64
        for </span><span class="cov0" title="0">{
                keys, next, err := database.RedisClient.Scan(ctx, cursor, redisArticleListPrefix+"*", 100).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">cursor = next
                if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                        _ = database.RedisClient.Del(ctx, keys...).Err()
                }</span>
                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

</pre>
		
		<pre class="file" id="file28" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"

        "github.com/google/uuid"
)

// CategoryService 分类服务，提供分类相关的业务逻辑
type CategoryService struct {
        categoryRepo *repository.CategoryRepository
}

// NewCategoryService 创建新的分类服务实例
// categoryRepo: 分类数据访问层仓库
func NewCategoryService(categoryRepo *repository.CategoryRepository) *CategoryService <span class="cov0" title="0">{
        return &amp;CategoryService{
                categoryRepo: categoryRepo,
        }
}</span>

// Create 创建新分类
// req: 分类创建请求，包含名称、描述、父分类ID、排序等
// 返回: 创建成功的分类对象，如果创建失败则返回错误
func (s *CategoryService) Create(req *models.CategoryCreate) (*models.Category, error) <span class="cov0" title="0">{
        category := &amp;models.Category{
                Name:        req.Name,
                Slug:        GenerateSlug(req.Name),
                Description: req.Description,
                ParentID:    req.ParentID,
                Order:       req.Order,
        }

        if err := s.categoryRepo.Create(category); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.categoryRepo.GetByID(category.ID)</span>
}

// GetByID 根据ID获取分类详情
// id: 分类UUID
// 返回: 分类对象，如果不存在则返回错误
func (s *CategoryService) GetByID(id uuid.UUID) (*models.Category, error) <span class="cov0" title="0">{
        return s.categoryRepo.GetByID(id)
}</span>

// List 获取所有分类列表
// 返回: 分类列表，如果查询失败则返回错误
func (s *CategoryService) List() ([]*models.Category, error) <span class="cov0" title="0">{
        return s.categoryRepo.List()
}</span>

// Update 更新分类信息
// id: 分类UUID
// req: 分类更新请求，包含可选的名称、描述、父分类ID、排序等
// 返回: 更新后的分类对象，如果更新失败则返回错误
func (s *CategoryService) Update(id uuid.UUID, req *models.CategoryUpdate) (*models.Category, error) <span class="cov0" title="0">{
        category, err := s.categoryRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                category.Name = *req.Name
                category.Slug = GenerateSlug(*req.Name)
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                category.Description = *req.Description
        }</span>

        <span class="cov0" title="0">if req.ParentID != nil </span><span class="cov0" title="0">{
                category.ParentID = req.ParentID
        }</span>

        <span class="cov0" title="0">if req.Order != nil </span><span class="cov0" title="0">{
                category.Order = *req.Order
        }</span>

        <span class="cov0" title="0">if err := s.categoryRepo.Update(category); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.categoryRepo.GetByID(id)</span>
}

// Delete 删除分类（软删除）
// id: 分类UUID
// 返回: 如果删除失败则返回错误
func (s *CategoryService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return s.categoryRepo.Delete(id)
}</span>

</pre>
		
		<pre class="file" id="file29" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"

        "github.com/google/uuid"
)

// CommentService 评论服务，提供评论相关的业务逻辑
type CommentService struct {
        commentRepo  *repository.CommentRepository
        articleRepo  *repository.ArticleRepository
}

// NewCommentService 创建新的评论服务实例
// commentRepo: 评论数据访问层仓库
// articleRepo: 文章数据访问层仓库，用于验证文章是否存在
func NewCommentService(
        commentRepo *repository.CommentRepository,
        articleRepo *repository.ArticleRepository,
) *CommentService <span class="cov0" title="0">{
        return &amp;CommentService{
                commentRepo: commentRepo,
                articleRepo: articleRepo,
        }
}</span>

// Create 创建新评论
// userID: 登录用户ID（可选，游客评论时为nil）
// ip: 评论者IP地址，用于记录
// req: 评论创建请求，包含文章ID、内容、作者信息等
// 返回: 创建成功的评论对象，如果创建失败则返回错误
// 注意: 新评论默认状态为pending（待审核），会异步更新文章评论数
func (s *CommentService) Create(userID *uuid.UUID, ip string, req *models.CommentCreate) (*models.Comment, error) <span class="cov0" title="0">{
        // 验证文章是否存在
        _, err := s.articleRepo.GetByID(req.ArticleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">comment := &amp;models.Comment{
                ArticleID: req.ArticleID,
                UserID:    userID,
                ParentID:  req.ParentID,
                Content:   req.Content,
                Author:    req.Author,
                Email:     req.Email,
                Website:   req.Website,
                IP:        ip,
                Status:    "pending", // 默认待审核
        }

        if err := s.commentRepo.Create(comment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新文章评论数
        <span class="cov0" title="0">go s.commentRepo.IncrementCommentCount(req.ArticleID)

        return s.commentRepo.GetByID(comment.ID)</span>
}

// GetByArticleID 获取指定文章下的评论列表（分页）
// articleID: 文章UUID
// page: 页码，从1开始
// pageSize: 每页数量，默认20
// 返回: 评论列表、总数，如果查询失败则返回错误
// 注意: 只返回父评论（parent_id为NULL的评论）
func (s *CommentService) GetByArticleID(articleID uuid.UUID, page, pageSize int) ([]*models.Comment, int64, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">return s.commentRepo.GetByArticleID(articleID, page, pageSize)</span>
}

// Update 更新评论信息
// id: 评论UUID
// req: 评论更新请求，包含可选的内容和状态
// 返回: 更新后的评论对象，如果更新失败则返回错误
func (s *CommentService) Update(id uuid.UUID, req *models.CommentUpdate) (*models.Comment, error) <span class="cov0" title="0">{
        comment, err := s.commentRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Content != nil </span><span class="cov0" title="0">{
                comment.Content = *req.Content
        }</span>

        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                comment.Status = *req.Status
        }</span>

        <span class="cov0" title="0">if err := s.commentRepo.Update(comment); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.commentRepo.GetByID(id)</span>
}

// Delete 删除评论（硬删除）
// id: 评论UUID
// 返回: 如果删除失败则返回错误
func (s *CommentService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return s.commentRepo.Delete(id)
}</span>

</pre>
		
		<pre class="file" id="file30" style="display: none">// Package services 提供业务逻辑层的服务实现
//
// 设计原则：
// 1. 单一职责：每个服务只负责一个业务领域
// 2. 依赖注入：通过构造函数注入依赖，便于测试和扩展
// 3. 错误处理：统一返回错误，由上层处理
// 4. 事务管理：在 Service 层协调多个 Repository 操作
package services

import (
        "context"
        "errors"
        "fmt"
        "io"
        "mime/multipart"
        "os"
        "path/filepath"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"
        "enterprise-blog/pkg/logger"

        "github.com/google/uuid"
        "image"
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"
)

// ImageService 图片服务，提供图片相关的业务逻辑
//
// 职责：
// - 图片上传（文件验证、存储、元数据管理）
// - 图片查询（列表、详情、搜索）
// - 图片更新（描述、标签）
// - 图片删除（软删除 + 文件删除）
//
// 设计考虑：
// - 文件存储：本地文件系统（生产环境可改为对象存储如 S3、OSS）
// - 元数据存储：PostgreSQL 数据库
// - 文件命名：使用 UUID 避免文件名冲突
// - 错误处理：文件操作失败时清理已创建的文件
type ImageService struct {
        imageRepo *repository.ImageRepository // 图片数据访问层
        uploadDir string                      // 图片上传目录路径
}

// NewImageService 创建新的图片服务实例
// imageRepo: 图片数据访问层仓库
// uploadDir: 图片上传目录路径
func NewImageService(imageRepo *repository.ImageRepository, uploadDir string) *ImageService <span class="cov0" title="0">{
        if uploadDir == "" </span><span class="cov0" title="0">{
                uploadDir = "./uploads/images"
        }</span>
        // 确保上传目录存在
        <span class="cov0" title="0">os.MkdirAll(uploadDir, 0755)
        return &amp;ImageService{
                imageRepo: imageRepo,
                uploadDir: uploadDir,
        }</span>
}

// Upload 上传图片
//
// 参数说明：
// - ctx: 上下文，用于控制请求超时和取消
// - uploaderID: 上传者用户UUID，用于记录图片归属
// - file: 上传的文件（multipart.FileHeader，来自 HTTP 请求）
// - description: 图片描述（可选），用于搜索和管理
// - tags: 图片标签列表（可选），用于分类和搜索
//
// 返回值：
// - *models.Image: 上传成功的图片对象（包含完整信息）
// - error: 如果上传失败则返回错误
//
// 功能流程：
// 1. 验证文件类型（MIME类型白名单）
// 2. 验证文件大小（防止过大文件）
// 3. 生成唯一文件名（UUID + 原始扩展名）
// 4. 保存文件到本地文件系统
// 5. 读取图片尺寸（宽度、高度）
// 6. 构建访问URL（相对路径）
// 7. 保存图片元数据到数据库
// 8. 返回完整图片对象
//
// 安全考虑：
// - 文件类型验证：只允许图片格式，防止上传恶意文件
// - 文件大小限制：防止DoS攻击
// - 文件名生成：使用UUID避免文件名冲突和路径遍历攻击
//
// 错误处理：
// - 如果文件保存失败，删除已创建的文件
// - 如果数据库保存失败，删除已上传的文件（保证数据一致性）
//
// 面试要点：
// - 为什么使用UUID作为文件名？避免文件名冲突，提高安全性
// - 如何处理并发上传？UUID保证唯一性，文件系统操作是原子的
// - 如何保证数据一致性？使用事务或失败时清理已创建的文件
func (s *ImageService) Upload(ctx context.Context, uploaderID uuid.UUID, file *multipart.FileHeader, description string, tags []string) (*models.Image, error) <span class="cov0" title="0">{
        // 步骤1：验证文件类型（MIME类型白名单）
        // 只允许常见的图片格式，防止上传恶意文件（如可执行文件）
        // 生产环境应该从配置文件读取允许的类型
        allowedMimeTypes := map[string]bool{
                "image/jpeg": true,
                "image/jpg":  true,
                "image/png":  true,
                "image/gif":  true,
                "image/webp": true,
        }

        mimeType := file.Header.Get("Content-Type")
        if !allowedMimeTypes[mimeType] </span><span class="cov0" title="0">{
                return nil, errors.New("unsupported image format, only JPEG, PNG, GIF, WebP are allowed")
        }</span>

        // 步骤2：验证文件大小
        // 限制文件大小，防止DoS攻击和存储空间浪费
        // TODO: 应该从 config.AppConfig.Upload.MaxSize 读取，这里使用常量简化
        <span class="cov0" title="0">const maxSize = 10 * 1024 * 1024 // 10MB
        if file.Size &gt; maxSize </span><span class="cov0" title="0">{
                return nil, errors.New("image size exceeds 10MB limit")
        }</span>

        // 步骤3：打开上传的文件
        // multipart.FileHeader 需要调用 Open() 方法获取文件内容
        <span class="cov0" title="0">src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open uploaded file: %w", err)
        }</span>
        <span class="cov0" title="0">defer src.Close() // 确保文件句柄关闭，释放资源

        // 步骤4：生成唯一文件名
        // 使用 UUID 作为文件名前缀，避免文件名冲突
        // 保留原始文件的扩展名，便于识别文件类型
        ext := filepath.Ext(file.Filename)
        filename := fmt.Sprintf("%s%s", uuid.New().String(), ext)
        filePath := filepath.Join(s.uploadDir, filename) // 构建完整文件路径

        // 步骤5：创建目标文件并保存
        // 使用 os.Create 创建新文件，如果文件已存在会被覆盖（UUID保证唯一性，不会发生）
        dst, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file: %w", err)
        }</span>
        <span class="cov0" title="0">defer dst.Close() // 确保文件句柄关闭

        // 使用 io.Copy 将上传的文件内容复制到目标文件
        // 这是高效的文件复制方式，支持大文件
        if _, err := io.Copy(dst, src); err != nil </span><span class="cov0" title="0">{
                os.Remove(filePath) // 如果复制失败，删除已创建的文件（清理资源）
                return nil, fmt.Errorf("failed to save file: %w", err)
        }</span>

        // 步骤6：读取图片尺寸
        // 需要重新打开文件，因为之前的文件句柄已经关闭
        // 使用 image.DecodeConfig 只解码图片配置（尺寸），不加载完整图片到内存，性能更好
        <span class="cov0" title="0">imgFile, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(filePath) // 如果打开失败，删除已保存的文件
                return nil, fmt.Errorf("failed to read image: %w", err)
        }</span>
        <span class="cov0" title="0">defer imgFile.Close()

        img, _, err := image.DecodeConfig(imgFile)
        if err != nil </span><span class="cov0" title="0">{
                os.Remove(filePath) // 如果解码失败，说明不是有效的图片文件，删除文件
                return nil, fmt.Errorf("failed to decode image: %w", err)
        }</span>

        // TODO: 生成缩略图（可选功能）
        // 实际生产环境可以使用第三方库如 github.com/nfnt/resize 或 imagemagick
        // 缩略图可以用于列表展示，减少带宽和加载时间

        // 步骤7：构建访问URL
        // 使用相对路径，前端会根据基础URL拼接完整地址
        // 生产环境应该配置完整的CDN地址或对象存储URL
        <span class="cov0" title="0">url := fmt.Sprintf("/uploads/images/%s", filename)

        // 步骤8：创建图片记录并保存到数据库
        // 保存图片的元数据：文件名、原始文件名、路径、URL、MIME类型、尺寸、上传者等
        image := &amp;models.Image{
                Filename:     filename,     // 存储的文件名（UUID）
                OriginalName: file.Filename, // 原始文件名（用户上传时的文件名）
                Path:         filePath,      // 文件系统路径（用于删除文件）
                URL:          url,           // 访问URL（用于前端显示）
                MimeType:     mimeType,      // MIME类型（用于HTTP响应头）
                Size:         file.Size,     // 文件大小（字节）
                Width:        img.Width,     // 图片宽度（像素）
                Height:       img.Height,    // 图片高度（像素）
                UploaderID:   uploaderID,    // 上传者ID（用于权限控制）
                Description:  description,   // 图片描述（用于搜索）
                Tags:         tags,          // 图片标签（用于分类和搜索）
        }

        // 保存到数据库
        if err := s.imageRepo.Create(ctx, image); err != nil </span><span class="cov0" title="0">{
                os.Remove(filePath) // 如果数据库保存失败，删除已上传的文件（保证数据一致性）
                return nil, fmt.Errorf("failed to save image record: %w", err)
        }</span>

        // 重新从数据库获取完整数据（包含关联信息，如上传者信息）
        // 这样可以确保返回的数据是最新的，包含数据库自动生成的字段（如ID、创建时间等）
        <span class="cov0" title="0">return s.imageRepo.GetByID(ctx, image.ID)</span>
}

// GetByID 根据ID获取图片详情
// id: 图片UUID
// 返回: 图片对象，如果不存在则返回错误
func (s *ImageService) GetByID(ctx context.Context, id uuid.UUID) (*models.Image, error) <span class="cov0" title="0">{
        return s.imageRepo.GetByID(ctx, id)
}</span>

// List 获取图片列表（分页、筛选、搜索）
// query: 图片查询条件
// 返回: 图片列表、总数，如果查询失败则返回错误
func (s *ImageService) List(ctx context.Context, query models.ImageQuery) ([]*models.Image, int64, error) <span class="cov0" title="0">{
        return s.imageRepo.List(ctx, query)
}</span>

// Update 更新图片信息
// id: 图片UUID
// req: 图片更新请求，包含可选的描述和标签
// 返回: 更新后的图片对象，如果更新失败则返回错误
func (s *ImageService) Update(ctx context.Context, id uuid.UUID, req *models.ImageUpdate) (*models.Image, error) <span class="cov0" title="0">{
        image, err := s.imageRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Description != nil </span><span class="cov0" title="0">{
                image.Description = *req.Description
        }</span>

        <span class="cov0" title="0">if req.Tags != nil </span><span class="cov0" title="0">{
                image.Tags = *req.Tags
        }</span>

        <span class="cov0" title="0">if err := s.imageRepo.Update(ctx, image); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.imageRepo.GetByID(ctx, id)</span>
}

// Delete 删除图片（软删除）
//
// 参数说明：
// - ctx: 上下文，用于控制请求超时和取消
// - id: 要删除的图片UUID
//
// 返回值：
// - error: 如果删除失败则返回错误
//
// 功能流程：
// 1. 从数据库获取图片信息（获取文件路径）
// 2. 删除文件系统中的文件
// 3. 软删除数据库记录（设置 deleted_at 字段）
//
// 设计考虑：
// - 软删除：数据库记录不真正删除，只标记为已删除，可以恢复
// - 文件删除：物理删除文件，释放存储空间
// - 错误处理：即使文件删除失败，也继续执行数据库删除（避免数据不一致）
//
// 面试要点：
// - 为什么使用软删除？可以恢复误删的数据，保留审计记录
// - 如何处理文件删除失败？记录警告日志，继续执行数据库删除，避免数据不一致
func (s *ImageService) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        // 先获取图片信息，获取文件路径
        image, err := s.imageRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 删除文件系统中的文件
        // 如果文件删除失败，记录警告日志但不中断流程
        // 这样可以避免文件删除失败导致数据库记录无法删除的情况
        <span class="cov0" title="0">if err := os.Remove(image.Path); err != nil </span><span class="cov0" title="0">{
                l := logger.GetLogger()
                l.Warn().Err(err).Str("path", image.Path).Msg("failed to delete image file")
                // 继续执行数据库删除，即使文件删除失败
        }</span>

        // 软删除数据库记录（设置 deleted_at 字段）
        // 软删除的好处：可以恢复数据，保留审计记录
        <span class="cov0" title="0">return s.imageRepo.Delete(ctx, id)</span>
}

// GetUploadDir 获取上传目录路径
func (s *ImageService) GetUploadDir() string <span class="cov0" title="0">{
        return s.uploadDir
}</span>

// GenerateThumbnail 生成缩略图（辅助函数，可选实现）
func (s *ImageService) GenerateThumbnail(ctx context.Context, imageID uuid.UUID, maxWidth, maxHeight uint) error <span class="cov0" title="0">{
        // 这里可以实现缩略图生成逻辑
        // 使用 image 包或第三方库如 github.com/nfnt/resize
        return nil
}</span>

</pre>
		
		<pre class="file" id="file31" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "context"
        "errors"
        "fmt"
        "math/rand"
        "time"

        "enterprise-blog/internal/database"
        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"
        "enterprise-blog/pkg/logger"
)

// SMSService 短信服务，提供短信验证码相关的业务逻辑
type SMSService struct {
        smsRepo  *repository.SMSRepository
        userRepo *repository.UserRepository
        jwtMgr   interface{} // 占位，实际需要 JWTManager
}

// NewSMSService 创建新的短信服务实例
// smsRepo: 短信验证码数据访问层仓库
// userRepo: 用户数据访问层仓库，用于查找或创建用户
func NewSMSService(smsRepo *repository.SMSRepository, userRepo *repository.UserRepository) *SMSService <span class="cov0" title="0">{
        return &amp;SMSService{
                smsRepo:  smsRepo,
                userRepo: userRepo,
        }
}</span>

// SetJWTManager 设置 JWT 管理器（在初始化时调用）
func (s *SMSService) SetJWTManager(jwtMgr interface{}) <span class="cov0" title="0">{
        s.jwtMgr = jwtMgr
}</span>

// LoginWithPhone 使用手机号和验证码登录，返回 token 和用户信息
func (s *SMSService) LoginWithPhone(phone, code string) (string, *models.User, error) <span class="cov0" title="0">{
        user, err := s.VerifyCode(phone, code)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        // 检查用户状态
        <span class="cov0" title="0">if user.Status != "active" </span><span class="cov0" title="0">{
                return "", nil, errors.New("user account is not active")
        }</span>

        // 生成 JWT token（需要 JWTManager，这里先返回错误，由 handler 层处理）
        // 实际应该在 handler 层调用 jwtMgr.GenerateToken
        <span class="cov0" title="0">return "", user, nil</span>
}

// SendCode 发送验证码（当前为模拟实现，实际应接入短信服务商）
func (s *SMSService) SendCode(phone string) error <span class="cov0" title="0">{
        // 检查最近1分钟内是否已发送过验证码（防刷）
        oneMinAgo := time.Now().Add(-1 * time.Minute)
        count, err := s.smsRepo.GetRecentCodeCount(phone, oneMinAgo)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check recent codes: %w", err)
        }</span>
        <span class="cov0" title="0">if count &gt;= 1 </span><span class="cov0" title="0">{
                return errors.New("验证码发送过于频繁，请稍后再试")
        }</span>

        // 生成6位数字验证码
        <span class="cov0" title="0">code := fmt.Sprintf("%06d", rand.Intn(1000000))

        // 验证码5分钟有效
        expiresAt := time.Now().Add(5 * time.Minute)

        smsCode := &amp;models.SMSCode{
                Phone:     phone,
                Code:      code,
                Used:      false,
                ExpiresAt: expiresAt,
        }

        if err := s.smsRepo.Create(smsCode); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save sms code: %w", err)
        }</span>

        // 同时存储到 Redis（如果可用），用于快速验证
        <span class="cov0" title="0">if database.RedisClient != nil </span><span class="cov0" title="0">{
                key := fmt.Sprintf("sms:code:%s", phone)
                ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                defer cancel()
                _ = database.RedisClient.Set(ctx, key, code, 5*time.Minute).Err()
        }</span>

        // TODO: 实际生产环境应调用短信服务商 API 发送短信
        // 当前为模拟实现，仅在日志中输出验证码（开发/测试环境）
        <span class="cov0" title="0">l := logger.GetLogger()
        l.Info().
                Str("phone", phone).
                Str("code", code).
                Msg("SMS code sent (simulated)")

        return nil</span>
}

// VerifyCode 验证验证码并返回用户（如果存在则返回，不存在则自动创建）
func (s *SMSService) VerifyCode(phone, code string) (*models.User, error) <span class="cov0" title="0">{
        // 先尝试从 Redis 快速验证
        if database.RedisClient != nil </span><span class="cov0" title="0">{
                key := fmt.Sprintf("sms:code:%s", phone)
                ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                defer cancel()
                storedCode, err := database.RedisClient.Get(ctx, key).Result()
                if err == nil &amp;&amp; storedCode == code </span><span class="cov0" title="0">{
                        // Redis 验证通过，标记数据库中的验证码为已使用
                        smsCode, err := s.smsRepo.GetValidCode(phone, code)
                        if err == nil </span><span class="cov0" title="0">{
                                _ = s.smsRepo.MarkAsUsed(smsCode.ID)
                        }</span>
                        <span class="cov0" title="0">_ = database.RedisClient.Del(ctx, key).Err()

                        // 查找或创建用户
                        return s.findOrCreateUser(phone)</span>
                }
        }

        // 从数据库验证
        <span class="cov0" title="0">smsCode, err := s.smsRepo.GetValidCode(phone, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("验证码无效或已过期")
        }</span>

        // 标记为已使用
        <span class="cov0" title="0">if err := s.smsRepo.MarkAsUsed(smsCode.ID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mark code as used: %w", err)
        }</span>

        // 删除 Redis 中的验证码
        <span class="cov0" title="0">if database.RedisClient != nil </span><span class="cov0" title="0">{
                key := fmt.Sprintf("sms:code:%s", phone)
                ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                defer cancel()
                _ = database.RedisClient.Del(ctx, key).Err()
        }</span>

        // 查找或创建用户
        <span class="cov0" title="0">return s.findOrCreateUser(phone)</span>
}

// findOrCreateUser 根据手机号查找用户，不存在则自动创建
func (s *SMSService) findOrCreateUser(phone string) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByPhone(phone)
        if err == nil </span><span class="cov0" title="0">{
                // 用户已存在
                return user, nil
        }</span>

        // 用户不存在，自动创建
        <span class="cov0" title="0">user = &amp;models.User{
                Phone:    phone,
                Username: fmt.Sprintf("user_%s", phone[len(phone)-4:]), // 使用手机号后4位作为默认用户名
                Email:    fmt.Sprintf("%s@phone.local", phone),          // 生成临时邮箱
                Password: "", // 手机号登录不需要密码
                Role:     models.RoleReader,
                Status:   "active",
        }

        // 生成一个随机密码（虽然不会用到，但数据库字段要求非空）
        user.Password = fmt.Sprintf("phone_%s_%d", phone, time.Now().Unix())
        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // 重新获取完整用户信息
        <span class="cov0" title="0">return s.userRepo.GetByID(user.ID)</span>
}

</pre>
		
		<pre class="file" id="file32" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"

        "github.com/google/uuid"
)

// TagService 标签服务，提供标签相关的业务逻辑
type TagService struct {
        tagRepo *repository.TagRepository
}

// NewTagService 创建新的标签服务实例
// tagRepo: 标签数据访问层仓库
func NewTagService(tagRepo *repository.TagRepository) *TagService <span class="cov0" title="0">{
        return &amp;TagService{
                tagRepo: tagRepo,
        }
}</span>

// Create 创建新标签
// req: 标签创建请求，包含名称和颜色
// 返回: 创建成功的标签对象，如果创建失败则返回错误
func (s *TagService) Create(req *models.TagCreate) (*models.Tag, error) <span class="cov0" title="0">{
        tag := &amp;models.Tag{
                Name:  req.Name,
                Slug:  GenerateSlug(req.Name),
                Color: req.Color,
        }

        if err := s.tagRepo.Create(tag); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.tagRepo.GetByID(tag.ID)</span>
}

// GetByID 根据ID获取标签详情
// id: 标签UUID
// 返回: 标签对象，如果不存在则返回错误
func (s *TagService) GetByID(id uuid.UUID) (*models.Tag, error) <span class="cov0" title="0">{
        return s.tagRepo.GetByID(id)
}</span>

// Update 更新标签信息
// id: 标签UUID
// req: 标签更新请求，包含可选的名称和颜色
// 返回: 更新后的标签对象，如果更新失败则返回错误
func (s *TagService) Update(id uuid.UUID, req *models.TagUpdate) (*models.Tag, error) <span class="cov0" title="0">{
        tag, err := s.tagRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                tag.Name = *req.Name
                tag.Slug = GenerateSlug(*req.Name)
        }</span>

        <span class="cov0" title="0">if req.Color != nil </span><span class="cov0" title="0">{
                tag.Color = *req.Color
        }</span>

        <span class="cov0" title="0">if err := s.tagRepo.Update(tag); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.tagRepo.GetByID(id)</span>
}

// Delete 删除标签（软删除）
// id: 标签UUID
// 返回: 如果删除失败则返回错误
func (s *TagService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return s.tagRepo.Delete(id)
}</span>

// List 获取所有标签列表
// 返回: 标签列表，如果查询失败则返回错误
func (s *TagService) List() ([]*models.Tag, error) <span class="cov0" title="0">{
        return s.tagRepo.List()
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package services 提供业务逻辑层的服务实现
package services

import (
        "errors"
        "fmt"
        "strings"

        "enterprise-blog/internal/models"
        "enterprise-blog/internal/repository"
        "enterprise-blog/pkg/jwt"

        "github.com/google/uuid"
)

// UserService 用户服务，提供用户相关的业务逻辑
type UserService struct {
        userRepo *repository.UserRepository
        jwtMgr   *jwt.JWTManager
}

// NewUserService 创建新的用户服务实例
// userRepo: 用户数据访问层仓库
// jwtMgr: JWT管理器，用于生成和验证token
func NewUserService(userRepo *repository.UserRepository, jwtMgr *jwt.JWTManager) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                userRepo: userRepo,
                jwtMgr:   jwtMgr,
        }
}</span>

// Register 用户注册
// req: 用户注册请求，包含用户名、邮箱、密码等信息
// 返回: 注册成功的用户对象（密码已清除），如果注册失败则返回错误
// 注意: 会检查邮箱和用户名是否已存在，密码使用bcrypt加密存储
func (s *UserService) Register(req *models.UserCreate) (*models.User, error) <span class="cov0" title="0">{
        // 检查邮箱是否已存在
        _, err := s.userRepo.GetByEmail(req.Email)
        if err == nil </span><span class="cov0" title="0">{
                return nil, errors.New("email already exists")
        }</span>

        // 检查用户名是否已存在
        <span class="cov0" title="0">_, err = s.userRepo.GetByUsername(req.Username)
        if err == nil </span><span class="cov0" title="0">{
                return nil, errors.New("username already exists")
        }</span>

        // 创建用户
        <span class="cov0" title="0">user := &amp;models.User{
                Username: req.Username,
                Email:    req.Email,
                Password: req.Password,
                Role:     req.Role,
        }

        if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = models.RoleReader
        }</span>

        // 加密密码
        <span class="cov0" title="0">if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>

        // 保存用户
        <span class="cov0" title="0">if err := s.userRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // 清除密码
        <span class="cov0" title="0">user.Password = ""
        return user, nil</span>
}

// Login 用户登录（邮箱密码方式）
// req: 用户登录请求，包含邮箱和密码
// 返回: JWT token、用户对象（密码已清除），如果登录失败则返回错误
// 注意: 会验证密码和用户状态，只有active状态的用户才能登录
func (s *UserService) Login(req *models.UserLogin) (string, *models.User, error) <span class="cov0" title="0">{
        // 获取用户
        user, err := s.userRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, errors.New("invalid email or password")
        }</span>

        // 验证密码
        <span class="cov0" title="0">if !user.CheckPassword(req.Password) </span><span class="cov0" title="0">{
                return "", nil, errors.New("invalid email or password")
        }</span>

        // 检查用户状态
        <span class="cov0" title="0">if user.Status != "active" </span><span class="cov0" title="0">{
                return "", nil, errors.New("user account is not active")
        }</span>

        // 生成JWT token
        <span class="cov0" title="0">token, err := s.jwtMgr.GenerateToken(user.ID, user.Username, string(user.Role))
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        // 清除密码
        <span class="cov0" title="0">user.Password = ""
        return token, user, nil</span>
}

// GetByID 根据ID获取用户详情
// id: 用户UUID
// 返回: 用户对象（密码已清除），如果不存在则返回错误
func (s *UserService) GetByID(id uuid.UUID) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">user.Password = ""
        return user, nil</span>
}

// Update 更新用户信息
// id: 用户UUID
// req: 用户更新请求，包含可选的用户名、邮箱、角色、头像、简介、状态等
// 返回: 更新后的用户对象（密码已清除），如果更新失败则返回错误
// 注意: 会检查用户名和邮箱是否已被其他用户使用
func (s *UserService) Update(id uuid.UUID, req *models.UserUpdate) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Username != nil </span><span class="cov0" title="0">{
                // 检查用户名是否已被其他用户使用
                existing, err := s.userRepo.GetByUsername(*req.Username)
                if err == nil &amp;&amp; existing.ID != id </span><span class="cov0" title="0">{
                        return nil, errors.New("username already exists")
                }</span>
                <span class="cov0" title="0">user.Username = *req.Username</span>
        }

        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                // 检查邮箱是否已被其他用户使用
                existing, err := s.userRepo.GetByEmail(*req.Email)
                if err == nil &amp;&amp; existing.ID != id </span><span class="cov0" title="0">{
                        return nil, errors.New("email already exists")
                }</span>
                <span class="cov0" title="0">user.Email = *req.Email</span>
        }

        <span class="cov0" title="0">if req.Role != nil </span><span class="cov0" title="0">{
                user.Role = *req.Role
        }</span>

        <span class="cov0" title="0">if req.Avatar != nil </span><span class="cov0" title="0">{
                user.Avatar = *req.Avatar
        }</span>

        <span class="cov0" title="0">if req.Bio != nil </span><span class="cov0" title="0">{
                user.Bio = *req.Bio
        }</span>

        <span class="cov0" title="0">if req.Status != nil </span><span class="cov0" title="0">{
                user.Status = *req.Status
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.Update(user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user.Password = ""
        return user, nil</span>
}

// Delete 删除用户（软删除）
// id: 用户UUID
// 返回: 如果删除失败则返回错误
func (s *UserService) Delete(id uuid.UUID) error <span class="cov0" title="0">{
        return s.userRepo.Delete(id)
}</span>

// ChangePassword 修改用户密码（需提供旧密码进行验证）
// id: 用户UUID
// oldPassword: 当前密码，用于验证用户身份
// newPassword: 新密码，将使用bcrypt加密后存储
// 返回: 如果旧密码错误或更新失败则返回错误
func (s *UserService) ChangePassword(id uuid.UUID, oldPassword, newPassword string) error <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // 校验旧密码
        <span class="cov0" title="0">if !user.CheckPassword(oldPassword) </span><span class="cov0" title="0">{
                return errors.New("invalid old password")
        }</span>
        // 设置新密码并哈希
        <span class="cov0" title="0">user.Password = newPassword
        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash password: %w", err)
        }</span>
        <span class="cov0" title="0">return s.userRepo.UpdatePassword(id, user.Password)</span>
}

// List 获取用户列表（分页）
// page: 页码，从1开始
// pageSize: 每页数量，最大100
// 返回: 用户列表、总数，如果查询失败则返回错误
// 注意: 返回的用户对象密码已清除
func (s *UserService) List(page, pageSize int) ([]*models.User, int64, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">users, total, err := s.userRepo.List(page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // 清除所有用户的密码
        <span class="cov0" title="0">for _, user := range users </span><span class="cov0" title="0">{
                user.Password = ""
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

// GenerateSlug 生成URL友好的slug字符串
// text: 原始文本
// 返回: 转换后的slug（小写、空格和下划线替换为连字符）
// 注意: 这是简单的实现，生产环境建议使用更完善的slug生成库
func GenerateSlug(text string) string <span class="cov0" title="0">{
        slug := strings.ToLower(text)
        slug = strings.ReplaceAll(slug, " ", "-")
        slug = strings.ReplaceAll(slug, "_", "-")
        return slug
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package jwt

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type Claims struct {
        UserID   uuid.UUID `json:"user_id"`
        Username string    `json:"username"`
        Role     string    `json:"role"`
        jwt.RegisteredClaims
}

type JWTManager struct {
        secret     string
        expireTime time.Duration
}

func NewJWTManager(secret string, expireTime time.Duration) *JWTManager <span class="cov0" title="0">{
        return &amp;JWTManager{
                secret:     secret,
                expireTime: expireTime,
        }
}</span>

func (m *JWTManager) GenerateToken(userID uuid.UUID, username, role string) (string, error) <span class="cov0" title="0">{
        claims := &amp;Claims{
                UserID:   userID,
                Username: username,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(m.expireTime)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        ID:        uuid.New().String(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(m.secret))
}</span>

func (m *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid signing method")
                }</span>
                <span class="cov0" title="0">return []byte(m.secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

</pre>
		
		<pre class="file" id="file35" style="display: none">package logger

import (
        "os"
        "path/filepath"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func Init(level, logFile string) error <span class="cov0" title="0">{
        // 解析日志级别
        logLevel, err := zerolog.ParseLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                logLevel = zerolog.DebugLevel
        }</span>
        <span class="cov0" title="0">zerolog.SetGlobalLevel(logLevel)

        // 配置时间格式
        zerolog.TimeFieldFormat = time.RFC3339

        // 如果指定了日志文件，则同时输出到文件和控制台
        if logFile != "" </span><span class="cov0" title="0">{
                // 确保日志目录存在
                if err := os.MkdirAll(filepath.Dir(logFile), 0755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 多写入器：同时输出到文件和控制台
                <span class="cov0" title="0">consoleWriter := zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339}
                multi := zerolog.MultiLevelWriter(consoleWriter, file)
                log.Logger = zerolog.New(multi).With().Timestamp().Logger()</span>
        } else<span class="cov0" title="0"> {
                // 仅输出到控制台
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339})
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetLogger() zerolog.Logger <span class="cov0" title="0">{
        return log.Logger
}</span>

</pre>
		
		<pre class="file" id="file36" style="display: none">// Package metrics 提供 Prometheus 监控指标
package metrics

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        // HTTP请求总数（按方法、路径、状态码）
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "path", "status"},
        )

        // HTTP请求持续时间（按方法、路径）
        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "path"},
        )

        // 活跃HTTP请求数
        httpRequestsInFlight = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "http_requests_in_flight",
                        Help: "Number of HTTP requests currently being processed",
                },
        )

        // 数据库查询总数
        dbQueriesTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "db_queries_total",
                        Help: "Total number of database queries",
                },
                []string{"operation", "table"},
        )

        // 数据库查询持续时间
        dbQueryDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "db_query_duration_seconds",
                        Help:    "Database query duration in seconds",
                        Buckets: []float64{.001, .005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
                },
                []string{"operation", "table"},
        )

        // Redis操作总数
        redisOperationsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "redis_operations_total",
                        Help: "Total number of Redis operations",
                },
                []string{"operation"},
        )

        // Redis操作持续时间
        redisOperationDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "redis_operation_duration_seconds",
                        Help:    "Redis operation duration in seconds",
                        Buckets: []float64{.0001, .0005, .001, .005, .01, .025, .05, .1},
                },
                []string{"operation"},
        )

        // 业务指标：用户注册数
        userRegistrationsTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "user_registrations_total",
                        Help: "Total number of user registrations",
                },
        )

        // 业务指标：文章创建数
        articleCreationsTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "article_creations_total",
                        Help: "Total number of articles created",
                },
        )

        // 业务指标：评论创建数
        commentCreationsTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "comment_creations_total",
                        Help: "Total number of comments created",
                },
        )

        // 业务指标：文章点赞数
        articleLikesTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "article_likes_total",
                        Help: "Total number of article likes",
                },
        )

        // 业务指标：当前在线用户数（示例）
        activeUsers = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "active_users",
                        Help: "Number of currently active users",
                },
        )
)

// RecordHTTPRequest 记录HTTP请求指标
func RecordHTTPRequest(method, path string, statusCode int, duration time.Duration) <span class="cov0" title="0">{
        status := prometheus.Labels{"method": method, "path": path, "status": string(rune(statusCode))}
        httpRequestsTotal.With(status).Inc()
        httpRequestDuration.WithLabelValues(method, path).Observe(duration.Seconds())
}</span>

// RecordHTTPRequestStart 开始记录HTTP请求（用于计算in-flight）
func RecordHTTPRequestStart() <span class="cov0" title="0">{
        httpRequestsInFlight.Inc()
}</span>

// RecordHTTPRequestEnd 结束记录HTTP请求
func RecordHTTPRequestEnd() <span class="cov0" title="0">{
        httpRequestsInFlight.Dec()
}</span>

// RecordDBQuery 记录数据库查询指标
func RecordDBQuery(operation, table string, duration time.Duration) <span class="cov0" title="0">{
        dbQueriesTotal.WithLabelValues(operation, table).Inc()
        dbQueryDuration.WithLabelValues(operation, table).Observe(duration.Seconds())
}</span>

// RecordRedisOperation 记录Redis操作指标
func RecordRedisOperation(operation string, duration time.Duration) <span class="cov0" title="0">{
        redisOperationsTotal.WithLabelValues(operation).Inc()
        redisOperationDuration.WithLabelValues(operation).Observe(duration.Seconds())
}</span>

// RecordUserRegistration 记录用户注册
func RecordUserRegistration() <span class="cov0" title="0">{
        userRegistrationsTotal.Inc()
}</span>

// RecordArticleCreation 记录文章创建
func RecordArticleCreation() <span class="cov0" title="0">{
        articleCreationsTotal.Inc()
}</span>

// RecordCommentCreation 记录评论创建
func RecordCommentCreation() <span class="cov0" title="0">{
        commentCreationsTotal.Inc()
}</span>

// RecordArticleLike 记录文章点赞
func RecordArticleLike() <span class="cov0" title="0">{
        articleLikesTotal.Inc()
}</span>

// SetActiveUsers 设置当前活跃用户数
func SetActiveUsers(count float64) <span class="cov0" title="0">{
        activeUsers.Set(count)
}</span>

// MetricsMiddleware Gin中间件，自动记录HTTP请求指标
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                RecordHTTPRequestStart()

                c.Next()

                duration := time.Since(start)
                statusCode := c.Writer.Status()
                RecordHTTPRequest(c.Request.Method, c.FullPath(), statusCode, duration)
                RecordHTTPRequestEnd()
        }</span>
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
